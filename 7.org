#+OPTIONS: toc:nil

* 7. 对象操作

本章介绍了 Chez Scheme 中针对非数值对象的特定操作，包括 pairs, numbers 等标准对象，以及 boxes, records 等 Chez Scheme 扩展对象。第 8 章介绍了针对数字的操作。关于对象的标准操作的更多描述，参见“The Scheme Programming Language，第 4 版”的第 6 章，或 Scheme 第 6 修订版的报告。

*** 7.1. R6RS 中缺少的类型判断

 过程: (enum-set? obj)

 返回: 如果 ~obj~ 为 =enum set= 则为 =#t=, 否则为 =#f=. 

 库: (chezscheme)

 此一谓词应当被定义，但缺失于第 6 修订版中。


 过程: (record-constructor-descriptor? obj)

 返回: 如果 ~obj~ 为 =record constructor= 则为 =#t=, 否则为 =#f=.

 库: (chezscheme)

 此一谓词应当被定义，但缺失于第 6 修订版中。


*** 7.2. 点对和列表

 过程: (atom? obj)

 返回: 如果 ~obj~ 不是点对，则为 =#t=, 否则为 =#f=.

 库: (chezscheme)

 atom? 等价于 (lambda (x) (not (pair? x))).

 #+BEGIN_SRC scheme
   (atom? '(a b c)) => #f
   (atom? '(3 . 4)) => #f
   (atom? '()) => #t
   (atom? 3) => #t
 #+END_SRC

 过程: (list-head list n)

 返回: 列表前 n 个元素的列表

 库: (chezscheme)

 n 须为一精确非负整数，且小于或等于列表的长度。

 ~list-head~ 可以和另一个 Scheme 标准过程 ~list-tail~ 配合，用于将一个列表分割成两个单独的列表。不过， ~list-tail~
 并不进行空间分配，只是返回原列表的子列表，而 ~list-head~ 则总是返回原列表前面部分的一份拷贝。

 ~list-head~ 可依如下定义：

 #+BEGIN_SRC scheme
   (define list-head
     (lambda (ls n)
       (if (= n 0)
           '()
           (cons (car ls) (list-head (cdr ls) (- n 1))))))

   (list-head '(a b c) 0) => ()
   (list-head '(a b c) 2) => (a b)
   (list-head '(a b c) 3) => (a b c)
   (list-head '(a b c . d) 2) => (a b)
   (list-head '(a b c . d) 3) => (a b c)
   (list-head '#1=(a . #1#) 5) => (a a a a a)
 #+END_SRC

 过程: (last-pair list)

 返回: 列表的最后一个点对

 库: (chezscheme)

 列表不可为空。 ~last-pair~ 返回列表的最后一个点对（不是最后一个元素）。列表可以是一个不严格的列表（improper list），此时，最后一个点对为一个包含最末元素和结束对象的点对。

 #+BEGIN_SRC scheme
   (last-pair '(a b c d)) => (d)
   (last-pair '(a b c . d)) => (c . d)
 #+END_SRC

 过程: (list-copy list)

 返回: 列表的一份拷贝

 库: (chezscheme)

 ~list-copy~ 返回与列表相等( ~equal?~ )的一个列表，使用新的点对重新构成顶层的列表结构。

 #+BEGIN_SRC scheme
   (list-copy '(a b c)) => (a b c)

   (let ([ls '(a b c)])
     (equal? ls (list-copy ls))) => #t

   (let ([ls '(a b c)])
     (let ([ls-copy (list-copy ls)])
       (or (eq? ls-copy ls)
           (eq? (cdr ls-copy) (cdr ls))
           (eq? (cddr ls-copy) (cddr ls))))) => #f
 #+END_SRC

 过程: (list* obj ... final-obj)

 返回: 由 ~obj ...~ 组成的列表，结束于 ~final-obj~

 库: (chezscheme)

 ~list*~ 和第 6 修订版中的 ~cons*~ 是一样的。

 过程: (make-list n)

 过程: (make-list n obj)

 返回: n 个对象的列表

 库: (chezscheme)

 n 须为非负整数。如果省略 obj，则列表的元素为未指定的。

 #+BEGIN_SRC scheme
   (make-list 0 '()) => ()
   (make-list 3 0) => (0 0 0)
   (make-list 2 "hi") => ("hi" "hi")
 #+END_SRC

 过程: (iota n)

 返回: 从 0（包含）到 n（不包含）的整数列表

 库: (chezscheme)

 n must be an exact nonnegative integer.
 n 须为精确的非负整数。

 #+BEGIN_SRC scheme
   (iota 0) => ()
   (iota 5) => (0 1 2 3 4)
 #+END_SRC

 过程: (enumerate ls)

 返回: 从 0（包含）到长度 ls（不包含）的整数列表。

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (enumerate '()) => ()
   (enumerate '(a b c)) => (0 1 2)
   (let ([ls '(a b c)])
     (map cons ls (enumerate ls))) => ((a . 0) (b . 1) (c . 2))
 #+END_SRC


 过程: (remq! obj list)

 过程: (remv! obj list)

 过程: (remove! obj list)

 返回: 列表中所有 ~obj~ 都被移除后的列表

 库: (chezscheme)

 这些过程与第 6 修订版中的 ~remq~, ~remv~, 及 ~remove~ 过程类似，只是 ~remq!~, ~remv!~ 和 ~remove!~ 使用输入列表中的点对来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。

 #+BEGIN_SRC scheme
   (remq! 'a '(a b a c a d)) => (b c d)
   (remv! #\a '(#\a #\b #\c)) => (#\b #\c)
   (remove! '(c) '((a) (b) (c))) => ((a) (b))
 #+END_SRC


 过程: (substq new old tree)

 过程: (substv new old tree)

 过程: (subst new old tree)

 过程: (substq! new old tree)

 过程: (substv! new old tree)

 过程: (subst! new old tree)

 返回: old 被替换为 new 后的树

 库: (chezscheme)

 这些过程遍历树，以对象 new 替换树中所有与对象 old 相等的对象。

 对于 ~substq~ 和 ~substq!~ ，相等性测试是基于 ~eq?~ , ~substv~ 和 ~substv!~ 是基于 ~eqv?~, 而 ~subst~ 和 ~subst!~ 是基于 ~equal?~.

 ~substq!~, ~substv!~, 和 ~subst!~ 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。

 #+BEGIN_SRC scheme
   (substq 'a 'b '((b c) b a)) => ((a c) a a)

   (substv 2 1 '((1 . 2) (1 . 4) . 1)) => ((2 . 2) (2 . 4) . 2)

   (subst 'a
          '(a . b)
          '((a . b) (c a . b) . c)) => (a (c . a) . c)

   (let ([tr '((b c) b a)])
     (substq! 'a 'b tr)
     tr) => ((a c) a a)
 #+END_SRC


 过程: (reverse! list)

 返回: 对原列表反向排序的列表

 库: (chezscheme)

 ~reverse!~ 通过反转其链接破坏性地反向排序列表。以 ~reverse!~ 取代 ~reverse~ 减少了空间分配，但并不一定比使用 ~reverse~ 更快。如果滥用，会很容易导致混乱或错误的结果。

 #+BEGIN_SRC scheme
   (reverse! '()) => ()
   (reverse! '(a b c)) => (c b a)

   (let ([x '(a b c)])
     (reverse! x)
     x) => (a)

   (let ([x '(a b c)])
     (set! x (reverse! x))
     x) => (c b a)
 #+END_SRC


 过程: (append! list ...)

 返回: 输入列表的串联

 库: (chezscheme)

 如同 ~append~, ~append!~ 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， ~append!~ 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个 ~cdr~, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。

 相比于 ~append~, ~append!~ 进行更少的空间分配，但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。

 #+BEGIN_SRC scheme
   (append! '(a b) '(c d)) => (a b c d)

   (let ([x '(a b)])
     (append! x '(c d))
     x) => (a b c d)
 #+END_SRC


*** 7.3. 字符

 Chez Scheme 以两种方式扩展了字符的语法。其一，前缀 ~#\~ 后面紧跟 3 位八进制数字会被读取为一个字符，其数字编码即为此 3 位数的八进制值，例如， ~#\044~ 被读取为 ~#\$~. 其二，它可以识别若干非标准命名的字符： ~#\rubout~ (等同于 ~#\delete~)， ~#\bel~ (等同于 ~#\alarm~), ~#\vt~ (等同于 ~#\vtab~), ~#\nel~ (Unicode NEL 字符), 以及 ~#\ls~ (Unicode LS 字符). 非标准字符的名字可以通过过程 ~char-name~ 更改（参见 9.14 节）。

 读取器若遇到 ~#!r6rs~ ，则这些扩展会在其后的输入流中被禁用，除非更接近的位置有 ~#!chezscheme~.

 过程: (char=? char1 char2 ...)

 过程: (char<? char1 char2 ...)

 过程: (char>? char1 char2 ...)

 过程: (char<=? char1 char2 ...)

 过程: (char>=? char1 char2 ...)

 过程: (char-ci=? char1 char2 ...)

 过程: (char-ci<? char1 char2 ...)

 过程: (char-ci>? char1 char2 ...)

 过程: (char-ci<=? char1 char2 ...)

 过程: (char-ci>=? char1 char2 ...)

 返回: 如果关系成立，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 这些谓词与第 6 修订版中的对应版本是一样的，只是被扩展为接受一个以上参数，而非两个以上参数。当只传入一个参数时，这些谓词均返回 ~#t~.

 #+BEGIN_SRC scheme
   (char>? #\a) => #t
   (char<? #\a) => #t
   (char-ci=? #\a) => #t
 #+END_SRC

 过程: (char- char1 char2)

 返回: 两个字符间的整数差值

 库: (chezscheme)

 ~char-~ 以 ~char1~ 的数值减去 ~char2~ 的数值，并返回差值。后面的例子假设字符的整数表示为其 ASCII 码。

 #+BEGIN_SRC scheme
   (char- #\f #\e) => 1

   (define digit-value
     ; return the digit value of the base-r digit c, or #f if c
     ; is not a valid digit
     (lambda (c r)
       (let ([v (cond
                 [(char<=? #\0 c #\9) (char- c #\0)]
                 [(char<=? #\A c #\Z) (char- c #\7)]
                 [(char<=? #\a c #\z) (char- c #\W)]
                 [else 36])])
         (and (fx< v r) v))))
   (digit-value #\8 10) => 8
   (digit-value #\z 10) => #f
   (digit-value #\z 36) => 35
 #+END_SRC

 ~char-~ 可依如下定义。
 
 #+BEGIN_SRC scheme
   (define char-
     (lambda (c1 c2)
       (- (char->integer c1) (char->integer c2))))
 #+END_SRC


*** 7.4. 字符串

 Chez Scheme extends the standard string syntax with two character escapes: \', which produces the single quote character, and \nnn, i.e., backslash followed by 3 octal digits, which produces the character equivalent of the octal value of the 3 digits. These extensions are disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently.

 All strings are mutable by default, including constants. A program can create immutable strings via string->immutable-string. Any attempt to modify an immutable string causes an exception to be raised.

 The length and indices of a string in Chez Scheme are always fixnums.

 过程: (string=? string1 string2 string3 ...)

 过程: (string<? string1 string2 string3 ...)

 过程: (string>? string1 string2 string3 ...)

 过程: (string<=? string1 string2 string3 ...)

 过程: (string>=? string1 string2 string3 ...)

 过程: (string-ci=? string1 string2 string3 ...)

 过程: (string-ci<? string1 string2 string3 ...)

 过程: (string-ci>? string1 string2 string3 ...)

 过程: (string-ci<=? string1 string2 string3 ...)

 过程: (string-ci>=? string1 string2 string3 ...)

 返回: 如果关系成立，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 这些谓词与第 6 修订版中的对应版本是一样的，只是被扩展为接受一个以上参数，而非两个以上参数。当只传入一个参数时，这些谓词均返回 ~#t~.

 #+BEGIN_SRC scheme
   (string>? "a") => #t
   (string<? "a") => #t
   (string-ci=? "a") => #t
 #+END_SRC


 过程: (string-copy! src src-start dst dst-start n)

 返回: unspecified

 库: (chezscheme)

 ~src~ 和 ~dst~ 必须是字符串，且 ~dst~ 必须可变。 ~src-start~, ~dst-start~, 以及 ~n~ 必须是非负整数。 ~src-start~ 和 ~n~ 的和不能超过 ~src~ 的长度， ~dst-start~ 和 ~n~ 的和不能超过 ~dst~ 的长度。

 ~string-copy!~ 以 ~src~ 中起始于 ~src-start~ 长度为 ~n~ 字节的部分，覆盖 ~dst~ 中起始于 ~dst-start~ ，长度为 ~n~ 字节的部分。即使 ~dst~ 和 ~src~ 是同一个字符串，且源和目标位置相互重叠，这个操作也能生效。即，在操作开始时，目标位置先被源字符串中的字符填充。

 #+BEGIN_SRC scheme
   (define s1 "to boldly go")
   (define s2 (make-string 10 #\-))

   (string-copy! s1 3 s2 1 3)
   s2 => "-bol------"

   (string-copy! s1 7 s2 4 2)
   s2 => "-bolly----"

   (string-copy! s2 2 s2 5 4)
   s2 => "-bollolly-"
 #+END_SRC


 过程: (substring-fill! string start end char)

 返回: unspecified

 库: (chezscheme)

 字符串必须是可变的。字符串于 ~start~ (包含) 和 ~end~ (不包含) 之间的字符均被设置为 ~char~. ~start~ 和 ~end~ 必须是非负整数； ~start~ 必须小于字符串的长度，而 ~end~ 可以小于或等于字符串的长度。如果 =end ≤ start=, 则字符串保持不变。

 #+BEGIN_SRC scheme
   (let ([str (string-copy "a tpyo typo")])
     (substring-fill! str 2 6 #\X)
     str) => "a XXXX typo"
 #+END_SRC


 过程: (string-truncate! string n)

 返回: 字符串或空字符串

 库: (chezscheme)

 字符串必须是可变的。 ~n~ 必须是精确的非负 ~fixnum~, 且不大于字符串的长度。如果 ~n~ 是 0, ~string-truncate!~ 返回空字符串。否则， ~string-truncate!~ 破坏性地把字符串缩短为其前 ~n~ 个字符，并返回此字符串。

 #+BEGIN_SRC scheme
   (define s (make-string 7 #\$))
   (string-truncate! s 0) => ""
   s => "$$$$$$$"
   (string-truncate! s 3) => "$$$"
   s => "$$$"
 #+END_SRC


 过程: (mutable-string? obj)

 返回: 如果 ~obj~ 是可变字符串，则为 ~#t~, 否则为 ~#f~.

 过程: (immutable-string? obj)

 返回: 如果 ~obj~ 是不可变字符串，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (mutable-string? (string #\a #\b #\c)) => #t
   (mutable-string? (string->immutable-string "abc")) => #f
   (immutable-string? (string #\a #\b #\c)) => #f
   (immutable-string? (string->immutable-string "abc")) => #t
   (immutable-string? (cons 3 4)) => #f
 #+END_SRC


 过程: (string->immutable-string string)

 返回: 与 ~string~ 相等(equal)的不可变字符串

 库: (chezscheme)

 如果 ~string~ 是不可变字符串，则结果为其本身；否则，结果是个不可变字符串，其内容与 ~string~ 相同。

 #+BEGIN_SRC scheme 
   (define s (string->immutable-string (string #\x #\y #\z)))
   (string-set! s 0 #\a) => exception: not mutable
 #+END_SRC


*** 7.5. Vectors
 Chez Scheme extends the syntax of vectors to allow the length of the vector to be specified between the # and open parenthesis, e.g., #3(a b c). If fewer elements are supplied in the syntax than the specified length, each element after the last printed element is the same as the last printed element. This extension is disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently.

 The length and indices of a vector in Chez Scheme are always fixnums.

 所有向量默认都是可变的，包括常量。程序可以通过 ~vector->immutable-vector~ 创建不可变向量。尝试修改不可变向量会导致抛出异常。

 过程: (vector-copy vector)

 返回: ~vector~ 的一份拷贝

 库: (chezscheme)

 ~vector-copy~ 生成一个长度和内容都和 ~vector~ 相同的新向量。里面的元素本身并不被复制。

 #+BEGIN_SRC scheme
   (vector-copy '#(a b c)) => #(a b c)

   (let ([v '#(a b c)])
     (eq? v (vector-copy v))) => #f
 #+END_SRC


 过程: (vector-set-fixnum! vector n fixnum)

 返回: unspecified

 库: (chezscheme)

 向量必须是不可变的。 ~vector-set-fixnum!~ 把向量的第 ~n~ 个元素变更为 ~fixnum~. ~n~ 必须是一个确切的非负整数，且严格小于 ~vector~ 的长度。

 It is faster to store a fixnum than an arbitrary value, since for arbitrary values, the system has to record potential assignments from older to younger objects to support generational garbage collection. Care must be taken to ensure that the argument is indeed a fixnum, however; otherwise, the collector may not properly track the assignment. The primitive performs a fixnum check on the argument except at optimization level 3.
 储存 ~fixnum~ 要比储存任意值快，因为对于任意值，

 参见后面关于仅由 =fixnum= 构成的向量 (=fxvectors=) 的描述。

 #+BEGIN_SRC scheme
   (let ([v (vector 1 2 3 4 5)])
     (vector-set-fixnum! v 2 73)
     v) => #(1 2 73 4 5)
 #+END_SRC


 过程: (vector-cas! vector n old-obj new-obj)

 返回: 如果 ~vector~ 有改变，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 向量必须是可变的。 若 ~vector~ 的第 ~n~ 个元素和 ~old-obj~ 相等（使用 ~eq?~ 判断相等性）, 则 ~vector-cas!~ 自动将此元素替换为 ~new-obj~, 若不相等，则 ~vector~ 保持不变。

 #+BEGIN_SRC scheme
   (define v (vector 'old0 'old1 'old2))
   (vector-cas! v 1 'old1 'new1) => #t
   (vector-ref v 1) => 'new1
   (vector-cas! v 2 'old1 'new2) => #f
   (vector-ref v 2) => 'old2
 #+END_SRC


 过程: (mutable-vector? obj)

 返回: 如果 ~obj~ 是可变向量，则为 ~#t~, 否则为 ~#f~.

 过程: (immutable-vector? obj)

 返回: 如果 ~obj~ 是不可变向量，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (mutable-vector? (vector 1 2 3)) => #t
   (mutable-vector? (vector->immutable-vector (vector 1 2 3))) => #f
   (immutable-vector? (vector 1 2 3)) => #f
   (immutable-vector? (vector->immutable-vector (vector 1 2 3))) => #t
   (immutable-vector? (cons 3 4)) => #f
 #+END_SRC


 过程: (vector->immutable-vector vector)

 返回: 与 ~vector~ 相等(equal)的一个不可变向量

 库: (chezscheme)

 如果 ~vector~ 是不可变向量，则结果为其本身；否则，结果是与 ~vector~ 内容相同的一个不可变向量。

 #+BEGIN_SRC scheme
   (define v (vector->immutable-vector (vector 1 2 3)))
   (vector-set! v 0 0) => exception: not mutable
 #+END_SRC


*** 7.6. 全定长数向量 (Fixnum-Only Vectors)

 Fixnum-only 向量, 即 "fxvectors", 类似于向量，但只包含 ~fixnums~. Fxvectors 的写法是以前缀 =#vfx= 替换向量的前缀 =#=, 例如， ~#vfx(1 2 3)~ 或 ~#10vfx(2)~. The fxvector syntax is disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently.

 ~fxvector~ 的长度和索引总是定长数。

 Updating an fxvector is generally less expensive than updating a vector, since for vectors, the system records potential assignments from older to younger objects to support generational garbage collection. The storage management system also takes advantage of the fact that fxvectors contain no pointers to place them in an area of memory that does not have to be traced during collection.
 更新 ~fxvector~ 通常比更新向量节省资源，因为对于向量来说，系统需要记录从老到新的各个对象的潜在分配，以支持分代垃圾回收。 =fxvectors= 不包含任何指针，受益于此，存储管理系统 TODO

 所有 ~fxvectors~ 默认是可变的，包括常量。程序可以通过 ~fxvector->immutable-fxvector~ 创建不可变的 ~fxvectors~. 尝试修改一个不可变的 ~fxvector~ 会导致异常抛出。

 可参考前述的 ~vector-set-fixnum!~.

 过程: (fxvector? obj)

 返回: 如果 ~obj~ 是一个 ~fxvector~, 则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (fxvector? #vfx()) => #t
   (fxvector? #vfx(1 2 3)) => #t
   (fxvector? (fxvector 1 2 3)) => #t
   (fxvector? '#(a b c)) => #f
   (fxvector? '(a b c)) => #f
   (fxvector? "abc") => #f
 #+END_SRC


 过程: (fxvector fixnum ...)

 返回: 一个由参数中的所有定长数组成的 ~fxvector~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (fxvector) => #vfx()
   (fxvector 1 3 5) => #vfx(1 3 5)
 #+END_SRC


 过程: (make-fxvector n)

 过程: (make-fxvector n fixnum)

 返回: 一个长度为 ~n~ 的 ~fxvector~.

 库: (chezscheme)

 n must be a fixnum. If fixnum is supplied, each element of the fxvector is initialized to fixnum; otherwise, the elements are unspecified.
 ~n~ 必须是定长数。如果有提供参数 ~fixnum~, 则 ~fxvector~ 中的每个元素都被初始化为 ~fixnum~; 不然，元素则均为未定义。

 #+BEGIN_SRC scheme
   (make-fxvector 0) => #vfx()
   (make-fxvector 0 7) => #vfx()
   (make-fxvector 5 7) => #vfx(7 7 7 7 7)
 #+END_SRC


 过程: (fxvector-length fxvector)

 返回: ~fxvector~ 中的元素个数

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (fxvector-length #vfx()) => 0
   (fxvector-length #vfx(1 2 3)) => 3
   (fxvector-length #10vfx(1 2 3)) => 10
   (fxvector-length (fxvector 1 2 3 4)) => 4
   (fxvector-length (make-fxvector 300)) => 300
 #+END_SRC


 过程: (fxvector-ref fxvector n)

 返回: ~fxvector~ 中的第 ~n~ 个元素 (索引基于 0)

 库: (chezscheme)

 ~n~ 必须是一个非负定长数，且严格小于 ~fxvector~ 的长度。

 #+BEGIN_SRC scheme
   (fxvector-ref #vfx(-1 2 4 7) 0) => -1
   (fxvector-ref #vfx(-1 2 4 7) 1) => 2
   (fxvector-ref #vfx(-1 2 4 7) 3) => 7
 #+END_SRC


 过程: (fxvector-set! fxvector n fixnum)

 返回: unspecified

 库: (chezscheme)

 ~fxvector~ 必须是可变的。 ~n~ 必须是一个非负定长数，且严格小于 ~fxvector~ 的长度。 ~fxvector-set!~ 把 ~fxvector~ 中的第 ~n~ 个元素修改为 ~fixnum~.

 #+BEGIN_SRC scheme
   (let ([v (fxvector 1 2 3 4 5)])
     (fxvector-set! v 2 (fx- (fxvector-ref v 2)))
     v) => #vfx(1 2 -3 4 5)
 #+END_SRC


 过程: (fxvector-fill! fxvector fixnum)

 返回: unspecified

 库: (chezscheme)

 ~fxvector~ 必须是可变的。 ~fxvector-fill!~ 把 ~fxvector~ 中的每个元素替换为 ~fixnum~.

 #+BEGIN_SRC scheme
   (let ([v (fxvector 1 2 3)])
     (fxvector-fill! v 0)
     v) => #vfx(0 0 0)
 #+END_SRC


 过程: (fxvector->list fxvector)

 返回: ~fxvector~ 中所有元素组成的列表

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (fxvector->list (fxvector)) => ()
   (fxvector->list #vfx(7 5 2)) => (7 5 2)

   (let ([v #vfx(1 2 3 4 5)])
     (apply fx* (fxvector->list v))) => 120
 #+END_SRC


 过程: (list->fxvector list)

 返回: 列表中所有元素组成的 ~fxvector~

 库: (chezscheme)

 ~list~ 必须完全由定长数组成。

 #+BEGIN_SRC scheme
   (list->fxvector '()) => #vfx()
   (list->fxvector '(3 5 7)) => #vfx(3 5 7)

   (let ([v #vfx(1 2 3 4 5)])
     (let ([ls (fxvector->list v)])
       (list->fxvector (map fx* ls ls)))) => #vfx(1 4 9 16 25)
 #+END_SRC


 过程: (fxvector-copy fxvector)

 返回: ~fxvector~ 的一份拷贝

 库: (chezscheme)

 ~fxvector-copy~ 生成一个与原 ~fxvector~ 长度和内容都一样的新的 ~fxvector~.

 #+BEGIN_SRC scheme
   (fxvector-copy #vfx(3 4 5)) => #vfx(3 4 5)

   (let ([v #vfx(3 4 5)])
     (eq? v (fxvector-copy v))) => #f
 #+END_SRC


 过程: (mutable-fxvector? obj)

 返回: 如果 ~obj~ 是一个可变的 ~fxvector~, 则为 ~#t~, 否则为 ~#f~.

 过程: (immutable-fxvector? obj)

 返回: 如果 ~obj~ 是一个不可变的 ~fxvector~, 则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (mutable-fxvector? (fxvector 1 2 3)) => #t
   (mutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) => #f
   (immutable-fxvector? (fxvector 1 2 3)) => #f
   (immutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) => #t
   (immutable-fxvector? (cons 3 4)) => #f
 #+END_SRC


 过程: (fxvector->immutable-fxvector fxvector)

 返回: ~fxvector~ 的一份不可变的拷贝或其自身

 库: (chezscheme)

 如果 ~fxvector~ 是不可变的，则结果为其本身；否则，结果是与原 ~fxvector~ 内容相同的一个不可变 ~fxvector~.

 #+BEGIN_SRC scheme
   (define v (fxvector->immutable-fxvector (fxvector 1 2 3)))
   (fxvector-set! v 0 0) => exception: not mutable
 #+END_SRC


*** 7.7. Bytevectors

 As with vectors, Chez Scheme extends the syntax of bytevectors to allow the length of the vector to be specified between the # and open parenthesis, e.g., #3vu8(1 105 73). If fewer elements are supplied in the syntax than the specified length, each element after the last printed element is the same as the last printed element. This extension is disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently.

 Chez Scheme also extends the set of bytevector primitives, including primitives for loading and storing 3, 5, 6, and 7-byte quantities.

 The length and indices of a bytevector in Chez Scheme are always fixnums.

 All bytevectors are mutable by default, including constants. A program can create immutable bytevectors via bytevector->immutable-bytevector. Any attempt to modify an immutable bytevector causes an exception to be raised.

 过程: (bytevector fill ...)
 返回: a new bytevector containing fill ...
 库: (chezscheme)

 Each fill value must be an exact integer representing a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent.

 (bytevector) => #vu8()
 (bytevector 1 3 5) => #vu8(1 3 5)
 (bytevector -1 -3 -5) => #vu8(255 253 251)

 过程: (bytevector->s8-list bytevector)
 返回: a new list of the 8-bit signed elements of bytevector
 库: (chezscheme)

 The values in the returned list are exact eight-bit signed integers, i.e., values in the range -128 to 127 inclusive. bytevector->s8-list is similar to the Revised6 Report bytevector->u8-list except the values in the returned list are signed rather than unsigned.

 (bytevector->s8-list (make-bytevector 0)) => ()
 (bytevector->s8-list #vu8(1 127 128 255)) => (1 127 -128 -1)

 (let ([v #vu8(1 2 3 255)])
   (apply * (bytevector->s8-list v))) => -6

 过程: (s8-list->bytevector list)
 返回: a new bytevector of the elements of list
 库: (chezscheme)

 list must consist entirely of exact eight-bit signed integers, i.e., values in the range -128 to 127 inclusive. s8-list->bytevector is similar to the Revised6 Report 过程 u8-list->bytevector, except the elements of the input list are signed rather than unsigned.

 (s8-list->bytevector '()) => #vu8()
 (s8-list->bytevector '(1 127 -128 -1)) => #vu8(1 127 128 255)

 (let ([v #vu8(1 2 3 4 5)])
   (let ([ls (bytevector->s8-list v)])
     (s8-list->bytevector (map - ls)))) => #vu8(255 254 253 252 251)

 过程: (bytevector-truncate! bytevector n)
 返回: bytevector or the empty bytevector
 库: (chezscheme)

 bytevector must be mutable. n must be an exact nonnegative fixnum not greater than the length of bytevector. If n is zero, bytevector-truncate! 返回 the empty bytevector. Otherwise, bytevector-truncate! destructively truncates bytevector to its first n bytes and 返回 bytevector.

 (define bv (make-bytevector 7 19))
 (bytevector-truncate! bv 0) => #vu8()
 bv => #vu8(19 19 19 19 19 19 19)
 (bytevector-truncate! bv 3) => #vu8(19 19 19)
 bv => #vu8(19 19 19)

 过程: (bytevector-u24-ref bytevector n eness)
 返回: the 24-bit unsigned integer at index n (zero-based) of bytevector
 过程: (bytevector-s24-ref bytevector n eness)
 返回: the 24-bit signed integer at index n (zero-based) of bytevector
 过程: (bytevector-u40-ref bytevector n eness)
 返回: the 40-bit unsigned integer at index n (zero-based) of bytevector
 过程: (bytevector-s40-ref bytevector n eness)
 返回: the 40-bit signed integer at index n (zero-based) of bytevector
 过程: (bytevector-u48-ref bytevector n eness)
 返回: the 48-bit unsigned integer at index n (zero-based) of bytevector
 过程: (bytevector-s48-ref bytevector n eness)
 返回: the 48-bit signed integer at index n (zero-based) of bytevector
 过程: (bytevector-u56-ref bytevector n eness)
 返回: the 56-bit unsigned integer at index n (zero-based) of bytevector
 过程: (bytevector-s56-ref bytevector n eness)
 返回: the 56-bit signed integer at index n (zero-based) of bytevector
 库: (chezscheme)

 n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of bytevector. eness must be a valid endianness symbol naming the endianness.

 The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

 过程: (bytevector-u24-set! bytevector n u24 eness)
 过程: (bytevector-s24-set! bytevector n s24 eness)
 过程: (bytevector-u40-set! bytevector n u40 eness)
 过程: (bytevector-s40-set! bytevector n s40 eness)
 过程: (bytevector-u48-set! bytevector n u48 eness)
 过程: (bytevector-s48-set! bytevector n s48 eness)
 过程: (bytevector-u56-set! bytevector n u56 eness)
 过程: (bytevector-s56-set! bytevector n s56 eness)
 返回: unspecified
 库: (chezscheme)

 bytevector must be mutable. n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. u24 must be a 24-bit unsigned value, i.e., a value in the range 0 to 224 - 1 inclusive; s24 must be a 24-bit signed value, i.e., a value in the range -223 to 223 - 1 inclusive; u40 must be a 40-bit unsigned value, i.e., a value in the range 0 to 240 - 1 inclusive; s40 must be a 40-bit signed value, i.e., a value in the range -239 to 239 - 1 inclusive; u48 must be a 48-bit unsigned value, i.e., a value in the range 0 to 248 - 1 inclusive; s48 must be a 48-bit signed value, i.e., a value in the range -247 to 247 - 1 inclusive; u56 must be a 56-bit unsigned value, i.e., a value in the range 0 to 256 - 1 inclusive; and s56 must be a 56-bit signed value, i.e., a value in the range -255 to 255 - 1 inclusive. eness must be a valid endianness symbol naming the endianness.

 These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index n (zero-based) of bytevector. Negative values are stored as their two's complement equivalent.

 过程: (mutable-bytevector? obj)
 返回: #t if obj is a mutable bytevector, #f otherwise
 过程: (immutable-bytevector? obj)
 返回: #t if obj is an immutable bytevector, #f otherwise
 库: (chezscheme)

 (mutable-bytevector? (bytevector 1 2 3)) => #t
 (mutable-bytevector?
   (bytevector->immutable-bytevector (bytevector 1 2 3))) => #f
 (immutable-bytevector? (bytevector 1 2 3)) => #f
 (immutable-bytevector?
   (bytevector->immutable-bytevector (bytevector 1 2 3))) => #t
 (immutable-bytevector? (cons 3 4)) => #f

 过程: (bytevector->immutable-bytevector bytevector)
 返回: an immutable bytevector equal to bytevector
 库: (chezscheme)

 The result is bytevector itself if bytevector is immutable; otherwise, the result is an immutable bytevector with the same content as bytevector.

 (define bv (bytevector->immutable-bytevector (bytevector 1 2 3)))
 (bytevector-u8-set! bv 0 0) => exception: not mutable

 过程: (bytevector-compress bytevector)
 返回: a new bytevector containing compressed content of bytevector
 库: (chezscheme)

 The result is the raw compressed data with a minimal header to record the uncompressed size and the compression mode. The result does not include the header that is written by port-based compression using the compressed option.

 过程: (bytevector-uncompress bytevector)
 返回: a bytevector containing uncompressed content of bytevector
 库: (chezscheme)

 Uncompresses a bytevector produced by bytevector-compress to a new bytevector with the same content as the original given to bytevector-compress.

*** 7.8. Boxes

 Boxes are single-cell objects that are primarily useful for providing an "extra level of indirection." This extra level of indirection is typically used to allow more than one body of code or data structure to share a reference, or pointer, to an object. For example, boxes may be used to implement call-by-reference semantics in an interpreter for a language employing this parameter passing discipline.

 Boxes are written with the prefix #& (pronounced "hash-ampersand"). For example, #&(a b c) is a box holding the list (a b c). The box syntax is disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently.

 All boxes are mutable by default, including constants. A program can create immutable boxes via box-immutable. Any attempt to modify an immutable box causes an exception to be raised.

 过程: (box? obj)
 返回: #t if obj is a box, #f otherwise
 库: (chezscheme)

 (box? '#&a) => #t
 (box? 'a) => #f
 (box? (box 3)) => #t

 过程: (box obj)
 返回: a new box containing obj
 库: (chezscheme)

 (box 'a) => #&a
 (box (box '(a b c))) => #&#&(a b c)

 过程: (unbox box)
 返回: contents of box
 库: (chezscheme)

 (unbox #&a) => a
 (unbox #&#&(a b c)) => #&(a b c)

 (let ([b (box "hi")])
   (unbox b)) => "hi"

 过程: (set-box! box obj)
 返回: unspecified
 库: (chezscheme)

 box must be mutable. set-box! sets the contents of box to obj.

 (let ([b (box 'x)])
   (set-box! b 'y)
   b) => #&y

 (let ([incr!
        (lambda (x)
          (set-box! x (+ (unbox x) 1)))])
   (let ([b (box 3)])
     (incr! b)
     (unbox b))) => 4

 过程: (box-cas! box old-obj new-obj)
 返回: #t if box is changed, #f otherwise
 库: (chezscheme)

 box must be mutable. box-cas! atomically changes the content of box to new-obj if the replaced content is eq? to old-obj. If the content of box that would be replaced is not eq? to old-obj, then box is unchanged.

 (define b (box 'old))
 (box-cas! b 'old 'new) => #t
 (unbox b) => 'new
 (box-cas! b 'other 'wrong) => #f
 (unbox b) => 'new

 过程: (mutable-box? obj)
 返回: #t if obj is a mutable box, #f otherwise
 过程: (immutable-box? obj)
 返回: #t if obj is an immutable box, #f otherwise
 库: (chezscheme)

 (mutable-box? (box 1)) => #t
 (mutable-box? (box-immutable 1)) => #f
 (immutable-box? (box 1)) => #f
 (immutable-box? (box-immutable 1)) => #t
 (mutable-box? (cons 3 4)) => #f

 过程: (box-immutable obj)
 返回: a new immutable box containing obj
 库: (chezscheme)

 Boxes are typically intended to support shared, mutable structure, so immutable boxes are not often useful.

 (define b (box-immutable 1))
 (set-box! b 0) => exception: not mutable

*** 7.9. Symbols

 Chez Scheme extends the standard symbol syntax in several ways:

     Symbol names may begin with @, but ,@abc is parsed as (unquote-splicing abc); to produce (unquote @abc) one can type , @abc, \x40;abc, or ,|@abc|.

     The single-character sequences { and } are read as symbols.

     A symbol's name may begin with any character that might normally start a number, including a digit, ., +, -, as long as the delimited sequence of characters starting with that character cannot be parsed as a number.

     A symbol whose name contains arbitrary characters may be written by escaping them with \ or with |. \ is used to escape a single character (except 'x', since \x marks the start of a hex scalar value), whereas | is used to escape the group of characters that follow it up through the matching |. 

 The printer always prints symbols using the standard R6RS syntax, so that, e.g., @abc prints as \x40;abc and 1- prints as \x31;-. '

 Gensyms are printed #{ and } brackets that enclose both the "pretty" and "unique" names, e.g., #{g1426 e5g1c94g642dssw-a}. They may also be printed using the pretty name only with the prefix #:, e.g., #:g1426.

 These extensions are disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently.

 过程: (gensym)
 过程: (gensym pretty-name)
 过程: (gensym pretty-name unique-name)
 返回: a unique generated symbol
 库: (chezscheme)

 Each call to gensym 返回 a unique generated symbol, or gensym. Each generated symbol has two names: a "pretty" name and a "unique" name.

 In the first form above, the pretty name is formed (lazily---see below) by combining an internal prefix with the value of an internal counter. After each name is formed, the internal counter is incremented. The parameters gensym-prefix and gensym-count, described below, may be used to access and set the internal prefix and counter. By default, the prefix is the single-character string "g". In the second and third forms, the pretty name of the new gensym is pretty-name, which must be a string. The pretty name of a gensym is returned by the 过程 symbol->string.

 In both the first and second forms, the unique name is an automatically generated globally unique name. Globally unique names are constructed (lazily---see below) from the combination of a universally unique identifier and an internal counter. In the third form of gensym, the unique name of the new gensym is unique-name, which must be a string. The unique name of a gensym may be obtained via the 过程 gensym->unique-string.

 The unique name allows gensyms to be written in such a way that they can be read back and reliably commonized on input. The syntax for gensyms includes both the pretty name and the unique name, as shown in the example below:

 (gensym) => #{g0 bcsfg5eq4e9b3h9o-a}

 When the parameter print-gensym is set to pretty, the printer prints the pretty name only, with a #: syntax, so

 (parameterize ([print-gensym 'pretty])
   (write (gensym)))

 prints #:g0.

 When the reader sees the #: syntax, it produces a gensym with the given pretty name, but the original unique name is lost.

 When the parameter is set to #f, the printer prints just the pretty name, so

 (parameterize ([print-gensym #f])
   (write (gensym)))

 prints g0. This is useful only when gensyms do not need to be read back in as gensyms.

 In order to reduce construction and (when threaded) synchronization overhead when gensyms are frequently created but rarely printed or stored in an object file, generated pretty and unique names are created lazily, i.e., not until first requested, either by the printer, fasl writer, or explicitly by one of the procedures symbol->string or gensym->unique-string. In addition, a gensym is not placed into the system's internal symbol table (the oblist; see page 156) until the unique name is requested. This allows a gensym to be reclaimed by the storage manager if no references to the gensym exist and no unique name exists by which to access it, even if it has a top-level binding or a nonempty property list.

 (define x (gensym))
 x                         => #{g2 bcsfg5eq4e9b3h9o-c}
 (symbol->string x)        => "g2"
 (gensym->unique-string x) => "bcsfg5eq4e9b3h9o-c"

 Gensyms subsume the notion of uninterned symbols supported by earlier versions of Chez Scheme. Similarly, the predicate uninterned-symbol? has been replaced by gensym?.

 thread parameter: gensym-prefix
 thread parameter: gensym-count
 库: (chezscheme)

 The parameters gensym-prefix and gensym-count are used to access and set the internal prefix and counter from which the pretty name of a gensym is generated when gensym is not given an explicit string argument. gensym-prefix defaults to the string "g" and may be set to any object. gensym-count starts at 0 and may be set to any nonnegative integer.

 As described above, Chez Scheme delays the creation of the pretty name until the name is first requested by the printer or by an explicit call to symbol->string. These parameters are not consulted until that time; setting them when gensym is called thus has no effect on the generated name.

 (let ([x (parameterize ([gensym-prefix "genny"]
                         [gensym-count 17]
                         [print-gensym 'pretty])
            (gensym))])
   (format "~s" x))                       => "#{g4 bcsfg5eq4e9b3h9o-e}"
 (let ([x (gensym)])
   (parameterize ([gensym-prefix "genny"]
                  [gensym-count 17]
                  [print-gensym #f])
     (format "~s" (gensym))))             => "genny17"

 过程: (gensym->unique-string gensym)
 返回: the unique name of gensym
 库: (chezscheme)

 (gensym->unique-string (gensym)) => "bd3kufa7ypjcuvut-g"

 过程: (gensym? obj)
 返回: #t if obj is gensym, #f otherwise
 库: (chezscheme)

 (gensym? (string->symbol "z")) => #f
 (gensym? (gensym "z")) => #t
 (gensym? 'a) => #f
 (gensym? 3) => #f
 (gensym? (gensym)) => #t
 (gensym? '#{g2 bcsfg5eq4e9b3h9o-c}) => #t

 过程: (putprop symbol key value)
 返回: unspecified
 库: (chezscheme)

 Chez Scheme associates a property list with each symbol, allowing multiple key-value pairs to be stored directly with the symbol. New key-value pairs may be placed in the property list or retrieved in a manner analogous to the use of association lists, using the procedures putprop and getprop. Property lists are often used to store information related to the symbol itself. For example, a natural language program might use symbols to represent words, using their property lists to store information about use and meaning.

 putprop associates value with key on the property list of symbol. key and value may be any types of object, although key is typically a symbol.

 putprop may be used to establish a new property or to change an existing property.

 See the examples under getprop below.

 过程: (getprop symbol key)
 过程: (getprop symbol key default)
 返回: the value associated with key on the property list of symbol
 库: (chezscheme)

 getprop searches the property list of symbol for a key identical to key (in the sense of eq?), and 返回 the value associated with this key, if any. If no value is associated with key on the property list of symbol, getprop 返回 default, or #f if the default argument is not supplied.

 (putprop 'fred 'species 'snurd)
 (putprop 'fred 'age 4)  
 (putprop 'fred 'colors '(black white))

 (getprop 'fred 'species) => snurd
 (getprop 'fred 'colors) => (black white)
 (getprop 'fred 'nonkey) => #f
 (getprop 'fred 'nonkey 'unknown) => unknown
 
 (putprop 'fred 'species #f)
 (getprop 'fred 'species 'unknown) => #f

 过程: (remprop symbol key)
 返回: unspecified
 库: (chezscheme)

 remprop removes the property with key key from the property list of symbol, if such a property exists.

 (putprop 'fred 'species 'snurd)
 (getprop 'fred 'species) => snurd

 (remprop 'fred 'species)
 (getprop 'fred 'species 'unknown) => unknown

 过程: (property-list symbol)
 返回: a copy of the internal property list for symbol
 库: (chezscheme)

 A property list is a list of alternating keys and values, i.e., (key value ...).

 (putprop 'fred 'species 'snurd)
 (putprop 'fred 'colors '(black white))
 (property-list 'fred) => (colors (black white) species snurd)

 过程: (oblist)
 返回: a list of interned symbols
 库: (chezscheme)

 The system maintains an internal symbol table used to insure that any two occurrences of the same symbol name resolve to the same symbol object. The oblist 过程 返回 a list of the symbols currently in this symbol table.

 The list of interned symbols grows when a new symbol is introduced into the system or when the unique name of a gensym (see page 152) is requested. It shrinks when the garbage collector determines that it is safe to discard a symbol. It is safe to discard a symbol only if the symbol is not accessible except through the oblist, has no top-level binding, and has no properties on its property list.

 (if (memq 'tiger (oblist)) 'yes 'no) => yes
 (equal? (oblist) (oblist)) => #t
 (= (length (oblist)) (length (oblist))) => #t or #f

 The first example above follows from the property that all interned symbols are in the oblist from the time they are read, which happens prior to evaluation. The second example follows from the fact that no symbols can be removed from the oblist while references to those symbols exist, in this case, within the list returned by the first call to oblist (whichever call is performed first). The expression in the third example can return #f only if a garbage collection occurs sometime between the two calls to oblist, and only if one or more symbols are removed from the oblist by that collection.

*** 7.10. Void

 Many Scheme operations return an unspecified result. Chez Scheme typically 返回 a special void object when the value returned by an operation is unspecified. The Chez Scheme void object is not meant to be used as a datum, and consequently does not have a reader syntax. As for other objects without a reader syntax, such as procedures and ports, Chez Scheme output procedures print the void object using a nonreadable representation, i.e., #<void>. Since the void object should be returned only by operations that do not have "interesting" values, the default waiter printer (see waiter-write) suppresses the printing of the void object. set!, set-car!, load, and write are examples of Chez Scheme operations that return the void object.

 过程: (void)
 返回: the void object
 库: (chezscheme)

 void is a 过程 of no arguments that 返回 the void object. It can be used to force expressions that are used for effect or whose values are otherwise unspecified to evaluate to a consistent, trivial value. Since most Chez Scheme operations that are used for effect return the void object, however, it is rarely necessary to explicitly invoke the void 过程.

 Since the void object is used explicitly as an "unspecified" value, it is a bad idea to use it for any other purpose or to count on any given expression evaluating to the void object.

 The default waiter printer suppresses the void object; that is, nothing is printed for expressions that evaluate to the void object.

 (eq? (void) #f) => #f
 (eq? (void) #t) => #f
 (eq? (void) '()) => #f

*** 7.11. Sorting

 过程: (sort predicate list)
 过程: (sort! predicate list)
 返回: a list containing the elements of list sorted according to predicate
 库: (chezscheme)

 sort is identical to the Revised6 Report list-sort, and sort! is a destructive version of sort, i.e., it reuses pairs from the input list to form the output list.

 (sort < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)
 (sort! < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)

 过程: (merge predicate list1 list2)
 过程: (merge! predicate list1 list2)
 返回: list1 merged with list2 in the order specified by predicate
 库: (chezscheme)

 predicate should be a 过程 that expects two arguments and 返回 #t if its first argument must precede its second in the merged list. It should not have any side effects. That is, if predicate is applied to two objects x and y, where x is taken from the second list and y is taken from the first list, it should return true only if x should appear before y in the output list. If this constraint is met, merge and merge! are stable, in that items from list1 are placed in front of equivalent items from list2 in the output list. Duplicate elements are included in the merged list.

 merge! combines the lists destructively, using pairs from the input lists to form the output list.

 (merge char<?
        '(#\a #\c)
        '(#\b #\c #\d)) => (#\a #\b #\c #\c #\d)
 (merge <
        '(1/2 2/3 3/4)
        '(0.5 0.6 0.7)) => (1/2 0.5 0.6 2/3 0.7 3/4)

*** 7.12. Hashtables

 Chez Scheme provides several extensions to the hashtable mechanism, including a mechanism for directly accessing a key, value pair in a hashtable, support for weak eq and eqv hashtables, and a set of procedures specialized to eq and symbol hashtables.

 过程: (hashtable-cell hashtable key default)
 返回: a pair (see below)
 库: (chezscheme)

 hashtable must be a hashtable. key and default may be any Scheme values.

 If no value is associated with key in hashtable, hashtable-cell modifies hashtable to associate key with default. It 返回 a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key in the car field should not be changed. The advantage of this 过程 over the Revised6 Report procedures for manipulating hashtable entries is that the value associated with a key may be read or written many times with only a single hashtable lookup.

 (define ht (make-eq-hashtable))
 (define v (vector 'a 'b 'c))
 (define cell (hashtable-cell ht v 3))
 cell => (#(a b c) . 3)
 (hashtable-ref ht v 0) => 3
 (set-cdr! cell 4)
 (hashtable-ref ht v 0) => 4

 过程: (hashtable-values hashtable)
 返回: a vector containing the values in hashtable
 库: (chezscheme)

 Each value is the value of one of the keys in hashtable. Duplicate values are not removed. The values may appear in any order in the returned vector.

 (define ht (make-eq-hashtable))
 (define p1 (cons 'a 'b))
 (define p2 (cons 'a 'b))
 (hashtable-set! ht p1 "one")
 (hashtable-set! ht p2 "two")
 (hashtable-set! ht 'q "two")
 (hashtable-values ht) => #("one" "two" "two")

 This 过程 is equivalent to:

 (lambda (ht)
   (let-values ([(keys values) (hashtable-entries ht)])
     values))

 but more efficient since the separate vector of keys need not be created.

 过程: (make-weak-eq-hashtable)
 过程: (make-weak-eq-hashtable size)
 过程: (make-weak-eqv-hashtable)
 过程: (make-weak-eqv-hashtable size)
 返回: a new weak eq hashtable
 库: (chezscheme)

 These procedures are like the Revised6 Report procedures make-eq-hashtable and make-eqv-hashtable except the keys of the hashtable are held weakly, i.e., they are not protected from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner.

 Values in the hashtable are referenced normally as long as the key is not reclaimed, since keys are paired values using weak pairs. Consequently, if a value in the hashtable refers to its own key, then garbage collection is prevented from reclaiming the key. See make-ephemeron-eq-hashtable and make-ephemeron-eqv-hashtable.

 A copy of a weak eq or eqv hashtable created by hashtable-copy is also weak. If the copy is immutable, inaccessible keys may still be dropped from the hashtable, even though the contents of the table is otherwise unchanging. The effect of this can be observed via hashtable-keys and hashtable-entries.

 (define ht1 (make-weak-eq-hashtable))
 (define ht2 (make-weak-eq-hashtable 32))

 过程: (make-ephemeron-eq-hashtable)
 过程: (make-ephemeron-eq-hashtable size)
 过程: (make-ephemeron-eqv-hashtable)
 过程: (make-ephemeron-eqv-hashtable size)
 返回: a new ephemeron eq hashtable
 库: (chezscheme)

 These procedures are like make-weak-eq-hashtable and make-weak-eqv-hashtable, but a value in the hashtable can refer to a key in the hashtable (directly or indirectly) without preventing garbage collection from reclaiming the key, because keys are paired with values using ephemeron pairs.

 A copy of an ephemeron eq or eqv hashtable created by hashtable-copy is also an ephemeron table, and an inaccesible key can be dropped from an immutable ephemeron hashtable in the same way as for an immutable weak hashtable.

 (define ht1 (make-ephemeron-eq-hashtable))
 (define ht2 (make-ephemeron-eq-hashtable 32))

 过程: (hashtable-weak? obj)
 返回: #t if obj is a weak eq or eqv hashtable, #f otherwise
 库: (chezscheme)

 (define ht1 (make-weak-eq-hashtable))
 (define ht2 (hashtable-copy ht1))
 (hashtable-weak? ht2) => #t

 过程: (hashtable-ephemeron? obj)
 返回: #t if obj is an ephemeron eq or eqv hashtable, #f otherwise
 库: (chezscheme)

 (define ht1 (make-ephemeron-eq-hashtable))
 (define ht2 (hashtable-copy ht1))
 (hashtable-ephemeron? ht2) => #t

 过程: (eq-hashtable? obj)
 返回: #t if obj is an eq hashtable, #f otherwise
 库: (chezscheme)

 (eq-hashtable? (make-eq-hashtable)) => #t
 (eq-hashtable? '(not a hash table)) => #f

 过程: (eq-hashtable-weak? hashtable)
 返回: #t if hashtable is weak, #f otherwise
 库: (chezscheme)

 hashtable must be an eq hashtable.

 (eq-hashtable-weak? (make-eq-hashtable)) => #f
 (eq-hashtable-weak? (make-weak-eq-hashtable)) => #t

 过程: (eq-hashtable-ephemeron? hashtable)
 返回: #t if hashtable uses ephemeron pairs, #f otherwise
 库: (chezscheme)

 hashtable must be an eq hashtable.

 (eq-hashtable-ephemeron? (make-eq-hashtable)) => #f
 (eq-hashtable-ephemeron? (make-ephemeron-eq-hashtable)) => #t

 过程: (eq-hashtable-set! hashtable key value)
 返回: unspecified
 库: (chezscheme)

 hashtable must be a mutable eq hashtable. key and value may be any Scheme values.

 eq-hashtable-set! associates the value value with the key key in hashtable.

 (define ht (make-eq-hashtable))
 (eq-hashtable-set! ht 'a 73)

 过程: (eq-hashtable-ref hashtable key default)
 返回: see below
 库: (chezscheme)

 hashtable must be an eq hashtable. key and default may be any Scheme values.

 eq-hashtable-ref 返回 the value associated with key in hashtable. If no value is associated with key in hashtable, eq-hashtable-ref 返回 default.

 (define ht (make-eq-hashtable))
 (define p1 (cons 'a 'b))
 (define p2 (cons 'a 'b))
 (eq-hashtable-set! ht p1 73)
 (eq-hashtable-ref ht p1 55) => 73
 (eq-hashtable-ref ht p2 55) => 55

 过程: (eq-hashtable-contains? hashtable key)
 返回: #t if an association for key exists in hashtable, #f otherwise
 库: (chezscheme)

 hashtable must be an eq hashtable. key may be any Scheme value.

 (define ht (make-eq-hashtable))
 (define p1 (cons 'a 'b))
 (define p2 (cons 'a 'b))
 (eq-hashtable-set! ht p1 73)
 (eq-hashtable-contains? ht p1) => #t
 (eq-hashtable-contains? ht p2) => #f

 过程: (eq-hashtable-update! hashtable key 过程 default)
 返回: unspecified
 库: (chezscheme)

 hashtable must be a mutable eq hashtable. key and default may be any Scheme values. 过程 should accept one argument, should return one value, and should not modify hashtable.

 eq-hashtable-update! applies 过程 to the value associated with key in hashtable, or to default if no value is associated with key in hashtable. If 过程 返回, eq-hashtable-update! associates key with the value returned by 过程, replacing the old association, if any.

 A version of eq-hashtable-update! that does not verify that it receives arguments of the proper type might be defined as follows.

 (define eq-hashtable-update!
   (lambda (ht key proc value)
     (eq-hashtable-set! ht key
       (proc (eq-hashtable-ref ht key value)))))

 An implementation may, however, be able to implement eq-hashtable-update! more efficiently by avoiding multiple hash computations and hashtable lookups.

 (define ht (make-eq-hashtable))
 (eq-hashtable-update! ht 'a
   (lambda (x) (* x 2))
   55)
 (eq-hashtable-ref ht 'a 0) => 110
 (eq-hashtable-update! ht 'a
   (lambda (x) (* x 2))
   0)
 (eq-hashtable-ref ht 'a 0) => 220

 过程: (eq-hashtable-cell hashtable key default)
 返回: a pair (see below)
 库: (chezscheme)

 hashtable must be an eq hashtable. key and default may be any Scheme values.

 If no value is associated with key in hashtable, eq-hashtable-cell modifies hashtable to associate key with default. It 返回 a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key should not be changed.

 (define ht (make-eq-hashtable))
 (define v (vector 'a 'b 'c))
 (define cell (eq-hashtable-cell ht v 3))
 cell => (#(a b c) . 3)
 (eq-hashtable-ref ht v 0) => 3
 (set-cdr! cell 4)
 (eq-hashtable-ref ht v 0) => 4

 过程: (eq-hashtable-delete! hashtable key)
 返回: unspecified
 库: (chezscheme)

 hashtable must be a mutable eq hashtable. key may be any Scheme value.

 eq-hashtable-delete! drops any association for key from hashtable.

 (define ht (make-eq-hashtable))
 (define p1 (cons 'a 'b))
 (define p2 (cons 'a 'b))
 (eq-hashtable-set! ht p1 73)
 (eq-hashtable-contains? ht p1) => #t
 (eq-hashtable-delete! ht p1)
 (eq-hashtable-contains? ht p1) => #f
 (eq-hashtable-contains? ht p2) => #f
 (eq-hashtable-delete! ht p2)

 过程: (symbol-hashtable? obj)
 返回: #t if obj is an eq hashtable, #f otherwise
 库: (chezscheme)

 (symbol-hashtable? (make-hashtable symbol-hash eq?)) => #t
 (symbol-hashtable? (make-eq-hashtable)) => #f

 过程: (symbol-hashtable-set! hashtable key value)
 返回: unspecified
 库: (chezscheme)

 hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and value may be any Scheme value.

 symbol-hashtable-set! associates the value value with the key key in hashtable.

 (define ht (make-hashtable symbol-hash eq?))
 (symbol-hashtable-ref ht 'a #f) => #f
 (symbol-hashtable-set! ht 'a 73)
 (symbol-hashtable-ref ht 'a #f) => 73

 过程: (symbol-hashtable-ref hashtable key default)
 返回: see below
 库: (chezscheme)

 hashtable must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and default may be any Scheme value.

 symbol-hashtable-ref 返回 the value associated with key in hashtable. If no value is associated with key in hashtable, symbol-hashtable-ref 返回 default.

 (define ht (make-hashtable symbol-hash eq?))
 (define k1 'abcd)
 (define k2 'not-abcd)
 (symbol-hashtable-set! ht k1 "hi")
 (symbol-hashtable-ref ht k1 "bye") => "hi"
 (symbol-hashtable-ref ht k2 "bye") => "bye"

 过程: (symbol-hashtable-contains? hashtable key)
 返回: #t if an association for key exists in hashtable, #f otherwise
 库: (chezscheme)

 hashtable must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol.

 (define ht (make-hashtable symbol-hash eq?))
 (define k1 'abcd)
 (define k2 'not-abcd)
 (symbol-hashtable-set! ht k1 "hi")
 (symbol-hashtable-contains? ht k1) => #t
 (symbol-hashtable-contains? ht k2 ) => #f

 过程: (symbol-hashtable-update! hashtable key 过程 default)
 返回: unspecified
 库: (chezscheme)

 hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and default may be any Scheme value. 过程 should accept one argument, should return one value, and should not modify hashtable.

 symbol-hashtable-update! applies 过程 to the value associated with key in hashtable, or to default if no value is associated with key in hashtable. If 过程 返回, symbol-hashtable-update! associates key with the value returned by 过程, replacing the old association, if any.

 A version of symbol-hashtable-update! that does not verify that it receives arguments of the proper type might be defined as follows.

 (define symbol-hashtable-update!
   (lambda (ht key proc value)
     (symbol-hashtable-set! ht key
       (proc (symbol-hashtable-ref ht key value)))))

 An implementation may, however, be able to implement symbol-hashtable-update! more efficiently by avoiding multiple hash computations and hashtable lookups.

 (define ht (make-hashtable symbol-hash eq?))
 (symbol-hashtable-update! ht 'a
   (lambda (x) (* x 2))
   55)
 (symbol-hashtable-ref ht 'a 0) => 110
 (symbol-hashtable-update! ht 'a
   (lambda (x) (* x 2))
   0)
 (symbol-hashtable-ref ht 'a 0) => 220

 过程: (symbol-hashtable-cell hashtable key default)
 返回: a pair (see below)
 库: (chezscheme)

 hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and default may be any Scheme value.

 If no value is associated with key in hashtable, symbol-hashtable-cell modifies hashtable to associate key with default. It 返回 a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key should not be changed.

 (define ht (make-hashtable symbol-hash eq?))
 (define k 'a-key)
 (define cell (symbol-hashtable-cell ht k 3))
 cell => (a-key . 3)
 (symbol-hashtable-ref ht k 0) => 3
 (set-cdr! cell 4)
 (symbol-hashtable-ref ht k 0) => 4

 过程: (symbol-hashtable-delete! hashtable key)
 返回: unspecified
 库: (chezscheme)

 hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol.

 symbol-hashtable-delete! drops any association for key from hashtable.

 (define ht (make-hashtable symbol-hash eq?))
 (define k1 (gensym))
 (define k2 (gensym))
 (symbol-hashtable-set! ht k1 73)
 (symbol-hashtable-contains? ht k1) => #t
 (symbol-hashtable-delete! ht k1)
 (symbol-hashtable-contains? ht k1) => #f
 (symbol-hashtable-contains? ht k2) => #f
 (symbol-hashtable-delete! ht k2)

*** 7.13. Record Types

 Chez Scheme extends the Revised6 Report's define-record-type syntax in one way, which is that it allows a generative record type to be declared explicitly as such (in a double-negative sort of way) by including a nongenerative clause with #f as the uid, i.e.:

 (nongenerative #f)

 This can be used in conjunction with the parameter require-nongenerative-clause to catch the accidental use of generative record types while avoiding spurious errors for record types that must be generative. Generative record types are rarely needed and are generally less efficient since a run-time representation of the type is created each time the define-record-clause is evaluated, rather than once at compile (expansion) time.

 thread parameter: require-nongenerative-clause
 库: (chezscheme)

 This parameter holds a boolean value that determines whether define-record-type requires a nongenerative clause. The default value is #f. The lead-in above describes why one might want to set this to #t.

*** 7.14. Record Equality and Hashing

 By default, the equal? primitive compares record instances using eq?, i.e., it distinguishes non-eq? instances even if they are of the same type and have equal contents. A program can override this behavior for instances of a record type (and its subtypes that do not have their own equality procedures) by using record-type-equal-procedure to associate an equality 过程 with the record-type descriptor (rtd) that describes the record type.

 When comparing two eq? instances, equal? always 返回 #t. When comparing two non-eq? instances that share an equality 过程 equal-proc, equal? uses equal-proc to compare the instances. Two instances x and y share an equality 过程 if they inherit an equality 过程 from the same point in the inheritance chain, i.e., if (record-equal-procedure x y) 返回 a 过程 (equal-proc) rather than #f. equal? passes equal-proc three arguments: the two instances plus a eql? 过程 that should be used for recursive comparison of values within the two instances. Use of eql? for recursive comparison is necessary to allow comparison of potentially cyclic structure. When comparing two non-eq? instances that do not share an equality 过程, equal? 返回 #f.

 A default equality 过程 to be used for all record types (including opaque types) can be specified via the parameter default-record-equal-procedure. The default equality 过程 is used only if neither instance's type has or inherits a type-specific record equality 过程.

 Similarly, when the equal-hash primitive hashes a record instance, it defaults to a value that is independent of the record type and contents of the instance. A program can override this behavior for instances of a record type by using record-type-hash-procedure to associate a hash 过程 with the record-type descriptor (rtd) that describes the record type. The 过程 record-hash-procedure can be used to find the hash 过程 for a given record instance, following the inheritance chain. equal-hash passes the hash 过程 two arguments: the instance plus a hash 过程 that should be used for recursive hashing of values within the instance. Use of hash for recursive hashing is necessary to allow hashing of potentially cyclic structure and to make the hashing of shared structure more efficient.

 A default hash 过程 to be used for all record types (including opaque types) can be specified via the parameter default-record-hash-procedure. The default hash 过程 is used only if an instance's type does not have or inherit a type-specific hash 过程.

 The following example illustrates the setting of equality and hash procedures.

 (define-record-type marble
   (nongenerative)
   (fields color quality))

 (record-type-equal-procedure (record-type-descriptor marble)) => #f
 (equal? (make-marble 'blue 'medium) (make-marble 'blue 'medium)) => #f
 (equal? (make-marble 'blue 'medium) (make-marble 'blue 'high)) => #f

 ; Treat marbles as equal when they have the same color
 (record-type-equal-procedure (record-type-descriptor marble)
   (lambda (m1 m2 eql?)
     (eql? (marble-color m1) (marble-color m2))))
 (record-type-hash-procedure (record-type-descriptor marble)
   (lambda (m hash)
     (hash (marble-color m))))

 (equal? (make-marble 'blue 'medium) (make-marble 'blue 'high)) => #t
 (equal? (make-marble 'red 'high) (make-marble 'blue 'high)) => #f

 (define ht (make-hashtable equal-hash equal?))
 (hashtable-set! ht (make-marble 'blue 'medium) "glass")
 (hashtable-ref ht (make-marble 'blue 'high) #f) => "glass"

 (define-record-type shooter
   (nongenerative)
   (parent marble)
   (fields size))

 (equal? (make-marble 'blue 'medium) (make-shooter 'blue 'large 17)) => #t
 (equal? (make-shooter 'blue 'large 17) (make-marble 'blue 'medium)) => #t
 (hashtable-ref ht (make-shooter 'blue 'high 17) #f) => "glass"

 This example illustrates the application of equality and hash procedures to cyclic record structures.

 (define-record-type node
   (nongenerative)
   (fields (mutable left) (mutable right)))

 (record-type-equal-procedure (record-type-descriptor node)
   (lambda (x y e?)
     (and
       (e? (node-left x) (node-left y))
       (e? (node-right x) (node-right y)))))
 (record-type-hash-procedure (record-type-descriptor node)
   (lambda (x hash)
     (+ (hash (node-left x)) (hash (node-right x)) 23)))

 (define graph1
   (let ([x (make-node "a" (make-node #f "b"))])
     (node-left-set! (node-right x) x)
     x))
 (define graph2
   (let ([x (make-node "a" (make-node (make-node "a" #f) "b"))])
     (node-right-set! (node-left (node-right x)) (node-right x))
     x))
 (define graph3
   (let ([x (make-node "a" (make-node #f "c"))])
     (node-left-set! (node-right x) x)
     x))

 (equal? graph1 graph2) => #t
 (equal? graph1 graph3) => #f
 (equal? graph2 graph3) => #f

 (define h (make-hashtable equal-hash equal?))
 (hashtable-set! h graph1 #t)
 (hashtable-ref h graph1 #f) => #t
 (hashtable-ref h graph2 #f) => #t
 (hashtable-ref h graph3 #f) => #f

 过程: (record-type-equal-procedure rtd equal-proc)
 返回: unspecified
 过程: (record-type-equal-procedure rtd)
 返回: equality 过程 associated with rtd, if any, otherwise #f
 库: (chezscheme)

 In the first form, equal-proc must be a 过程 or #f. If equal-proc is a 过程, a new association between rtd and equal-proc is established, replacing any existing such association. If equal-proc is #f, any existing association between rtd and an equality 过程 is dropped.

 In the second form, record-type-equal-procedure 返回 the equality 过程 associated with rtd, if any, otherwise #f.

 When changing a record type's equality 过程, the record type's hash 过程, if any, should be updated if necessary to maintain the property that it produces the same hash value for any two instances the equality 过程 considers equal.

 过程: (record-equal-procedure record1 record2)
 返回: the shared equality 过程 for record1 and record2, if there is one, otherwise #f
 库: (chezscheme)

 record-equal-procedure traverses the inheritance chains for both record instances in an attempt to find the most specific type for each that is associated with an equality 过程, if any. If such type is found and is the same for both instances, the equality 过程 associated with the type is returned. Otherwise, #f is returned.

 过程: (record-type-hash-procedure rtd hash-proc)
 返回: unspecified
 过程: (record-type-hash-procedure rtd)
 返回: hash 过程 associated with rtd, if any, otherwise #f
 库: (chezscheme)

 In the first form, hash-proc must be a 过程 or #f. If hash-proc is a 过程, a new association between rtd and hash-proc is established, replacing any existing such association. If hash-proc is #f, any existing association between rtd and a hash 过程 is dropped.

 In the second form, record-type-hash-procedure 返回 the hash 过程 associated with rtd, if any, otherwise #f.

 The 过程 hash-proc should accept two arguments, the instance for which it should compute a hash value and a hash 过程 to use to compute hash values for arbitrary fields of the instance, and it return a nonnegative exact integer. A record type's hash 过程 should produce the same hash value for any two instances the record type's equality 过程 considers equal.

 过程: (record-hash-procedure record)
 返回: the hash 过程 for record, if there is one, otherwise #f
 库: (chezscheme)

 record-hash-procedure traverses the inheritance chain for the record instance in an attempt to find the most specific type that is associated with a hash 过程, if any. If such type is found, the hash 过程 associated with the type is returned. Otherwise, #f is returned.

 thread parameter: default-record-equal-procedure
 库: (chezscheme)

 This parameter determines how two record instances are compared by equal? if neither has a type-specific equality 过程. When the parameter has the value #f (the default), equal? compares the instances with eq?, i.e., there is no attempt at determining structural equivalence. Otherwise, the parameter's value must be a 过程, and equal? invokes that 过程 to compare the instances, passing it three arguments: the two instances and a 过程 that should be used to recursively compare arbitrary values within the instances.

 thread parameter: default-record-hash-procedure
 库: (chezscheme)

 This parameter determines the hash 过程 used when equal-hash is called on a record instance and the instance does not have a type-specific hash 过程. When the parameter has the value #f (the default), equal-hash 返回 a value that is independent of the record type and contents of the instance. Otherwise, the parameter's value must be a 过程, and equal-hash invokes the 过程 to compute the instance's hash value, passing it the record instance and a 过程 to invoke to recursively compute hash values for arbitrary values contained within the record. The 过程 should return a nonnegative exact integer, and the return value should be the same for any two instances the default equal 过程 considers equivalent.

*** 7.15. Legacy Record Types

 In addition to the Revised6 Report record-type creation and definition mechanisms, which are described in Chapter 9 of The Scheme Programming Language, 4th Edition, Chez Scheme continues to support pre-R6RS mechanisms for creating new data types, or record types, with fixed sets of named fields. Many of the procedures described in this section are available only when imported from the (chezscheme csv7) library.

 Code intended to be portable should use the R6RS mechanism instead.

 Records may be defined via the define-record syntactic form or via the make-record-type 过程. The underlying representation of records and record-type descriptors is the same for the Revised6 Report mechanism and the alternative mechanism. Record types created by one can be used as parent record types for the other via the procedural mechanisms, though not via the syntactic mechanisms.

 The syntactic (define-record) interface is the most commonly used interface. Each define-record form defines a constructor 过程 for records of the new type, a type predicate that 返回 true only for records of the new type, an access 过程 for each field, and an assignment 过程 for each mutable field. For example,

 (define-record point (x y))

 creates a new point record type with two fields, x and y, and defines the following procedures:

 (make-point x y) 	constructor
 (point? obj) 	predicate
 (point-x p) 	accessor for field x
 (point-y p) 	accessor for field y
 (set-point-x! p obj) 	mutator for field x
 (set-point-y! p obj) 	mutator for field y

 The names of these procedures follow a regular naming convention by default, but the programmer can override the defaults if desired. define-record allows the programmer to control which fields are arguments to the generated constructor 过程 and which are explicitly initialized by the constructor 过程. Fields are mutable by default, but may be declared immutable. Fields can generally contain any Scheme value, but the internal representation of each field may be specified, which places implicit constraints on the type of value that may be stored there. These customization options are covered in the formal description of define-record later in this section.

 The procedural (make-record-type) interface may be used to implement interpreters that must handle define-record forms. Each call to make-record-type 返回 a record-type descriptor representing the record type. Using this record-type descriptor, programs may generate constructors, type predicates, field accessors, and field mutators dynamically. The following code demonstrates how the procedural interface might be used to create a similar point record type and associated definitions.

 (define point (make-record-type "point" '(x y)))
 (define make-point (record-constructor point))
 (define point? (record-predicate point))
 (define point-x (record-field-accessor point 'x))
 (define point-y (record-field-accessor point 'y))
 (define set-point-x! (record-field-mutator point 'x))
 (define set-point-y! (record-field-mutator point 'y))

 The procedural interface is more flexible than the syntactic interface, but this flexibility can lead to less readable programs and compromises the compiler's ability to generate efficient code. Programmers should use the syntactic interface whenever it suffices.

 A record-type descriptor may also be extracted from an instance of a record type, whether the record type was produced by define-record or make-record-type, and the extracted descriptor may also be used to produce constructors, predicates, accessors, and mutators, with a few limitations noted in the description of record-type-descriptor below. This is a powerful feature that permits the coding of portable printers and object inspectors. For example, the printer employs this feature in its default record printer, and the inspector uses it to allow inspection and mutation of system- and user-defined records during debugging.

 A parent record may be specified in the define-record syntax or as an optional argument to make-record-type. A new record inherits the parent record's fields, and each instance of the new record type is considered to be an instance of the parent type as well, so that accessors and mutators for the parent type may be used on instances of the new type.

 Record type definitions may be classified as either generative or nongenerative. A new type results for each generative record definition, while only one type results for all occurrences of a given nongenerative record definition. This distinction is important semantically since record accessors and setters are applicable only to objects with the same type.

 Syntactic (define-record) record definitions are expand-time generative by default, which means that a new record is created when the code is expanded. Expansion happens once for each form prior to compilation or interpretation, as when it is entered interactively, loaded from source, or compiled by compile-file. As a result, multiple evaluations of a single define-record form, e.g., in the body of a 过程 called multiple times, always produce the same record type.

 Separate define-record forms usually produce different types, even if the forms are textually identical. The only exception occurs when the name of a record is specified as a generated symbol, or gensym (page 152). Multiple copies of a record definition whose name is given by a gensym always produce the same record type; i.e., such definitions are nongenerative. Each copy of the record definition must contain the same fields and field modifiers in the same order; an exception is raised with condition-type &assertion when two differing record types with the same generated name are loaded into the same Scheme process.

 Procedural (make-record-type) record definitions are run-time generative by default. That is, each call to make-record-type usually produces a new record type. As with the syntactic interface, the only exception occurs when the name of the record is specified as a gensym, in which case the record type is fully nongenerative.

 By default, a record is printed with the syntax

 #[type-name field ...]

 where field ... are the printed representations of the contents of the fields of the record, and type-name is a generated symbol, or gensym (page 152), that uniquely identifies the record type. For nongenerative records, type-name is the gensym provided by the program. Otherwise, it is a gensym whose "pretty" name (page 152) is the name given to the record by define-record or make-record-type.

 The default printing of records of a given type may be overridden with record-writer.

 The default syntax may be used as input to the reader as well, as long as the corresponding record type has already been defined in the Scheme session in which the read occurs. The parameter record-reader may be used to specify a different name to be recognized by the reader in place of the generated name. Specifying a different name in this manner also changes the name used when the record is printed. This reader extension is disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently.

 The mark (#n=) and reference (#n#) syntaxes may be used within the record syntax, with the result of creating shared or cyclic structure as desired. All cycles must be resolvable, however, without mutation of an immutable record field. That is, any cycle must contain at least one pointer through a mutable field, whether it is a mutable record field or a mutable field of a built-in object type such as a pair or vector.

 When the parameter print-record is set to #f, records are printed using the simpler syntax

 #<record of type name>

 where name is the "pretty" name of the record (not the full gensym) or the reader name first assigned to the record type.

 syntax: (define-record name (fld1 ...) ((fld2 init) ...) (opt ...))
 syntax: (define-record name parent (fld1 ...) ((fld2 init) ...) (opt ...))
 返回: unspecified
 库: (chezscheme)

 A define-record form is a definition and may appear anywhere and only where other definitions may appear.

 define-record creates a new record type containing a specified set of named fields and defines a set of procedures for creating and manipulating instances of the record type.

 name must be an identifier. If name is a generated symbol (gensym), the record definition is nongenerative, otherwise it is expand-time generative. (See the discussion of generativity earlier in this section.)

 Each fld must be an identifier field-name, or it must take the form

 (class type field-name)

 where class and type are optional and field-name is an identifier. class, if present, must be the keyword immutable or the keyword mutable. If the immutable class specifier is present, the field is immutable; otherwise, the field is mutable. type, if present, specifies how the field is represented, as described below.

 ptr 	any Scheme object
 scheme-object 	same as ptr
 int 	a C int
 unsigned 	a C unsigned int
 short 	a C short
 unsigned-short 	a C unsigned short
 long 	a C long
 unsigned-long 	a C unsigned long
 iptr 	a signed integer the size of a ptr
 uptr 	an unsigned integer the size of a ptr
 float 	a C float
 double 	a C double
 integer-8 	an eight-bit signed integer
 unsigned-8 	an eight-bit unsigned integer
 integer-16 	a 16-bit signed integer
 unsigned-16 	a 16-bit unsigned integer
 integer-32 	a 32-bit signed integer
 unsigned-32 	a 32-bit unsigned integer
 integer-64 	a 64-bit signed integer
 unsigned-64 	a 64-bit unsigned integer
 single-float 	a 32-bit single floating point number
 double-float 	a 64-bit double floating point number

 If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type ptr, meaning that it can contain any Scheme object.

 The field identifiers name the fields of the record. The values of the n fields described by fld1 ... are specified by the n arguments to the generated constructor 过程. The values of the remaining fields, fld2 ..., are given by the corresponding expressions, init .... Each init is evaluated within the scope of the set of field names given by fld1 ... and each field in fld2 ... that precedes it, as if within a let* expression. Each of these field names is bound to the value of the corresponding field during initialization.

 If parent is present, the record type named by parent is the parent of the record. The new record type inherits each of the parent record's fields, and records of the new type are considered records of the parent type. If parent is not present, the parent record type is a base record type with no fields.

 The following procedures are defined by define-record:

     a constructor 过程 whose name is make-name,

     a type predicate whose name is name?,

     an access 过程 whose name is name-fieldname for each noninherited field, and

     an assignment 过程 whose name is set-name-fieldname! for each noninherited mutable field. 

 If no parent record type is specified, the constructor behaves as if defined as

 (define make-name
   (lambda (id1 ...)
     (let* ([id2 init] ...)
       body)))

 where id1 ... are the names of the fields defined by fld1 ..., id2 ... are the names of the fields defined by fld2 ..., and body builds the record from the values of the identifiers id1 ... and id2 ....

 If a parent record type is specified, the parent arguments appear first, and the parent fields are inserted into the record before the child fields.

 The options opt ... control the selection of names of the generated constructor, predicate, accessors, and mutators.

 (constructor id)
 (predicate id)
 (prefix string)

 The option (constructor id) causes the generated constructor's name to be id rather than make-name. The option (predicate id) likewise causes the generated predicate's name to be id rather than name?. The option (prefix string) determines the prefix to be used in the generated accessor and mutator names in place of name-.

 If no options are needed, the third subexpression, (opt ...), may be omitted. If no options and no fields other than those initialized by the arguments to the constructor 过程 are needed, both the second and third subexpressions may be omitted. If options are specified, the second subexpression must be present, even if it contains no field specifiers.

 Here is a simple example with no inheritance and no options.

 (define-record marble (color quality))
 (define x (make-marble 'blue 'medium))
 (marble? x) => #t
 (pair? x) => #f
 (vector? x) => #f
 (marble-color x) => blue
 (marble-quality x) => medium
 (set-marble-quality! x 'low)
 (marble-quality x) => low

 (define-record marble ((immutable color) (mutable quality))
   (((mutable shape) (if (eq? quality 'high) 'round 'unknown))))
 (marble-shape (make-marble 'blue 'high)) => round
 (marble-shape (make-marble 'blue 'low)) => unknown
 (define x (make-marble 'blue 'high))
 (set-marble-quality! x 'low)
 (marble-shape x) => round
 (set-marble-shape! x 'half-round)
 (marble-shape x) => half-round

 The following example illustrates inheritance.

 (define-record shape (x y))
 (define-record point shape ())
 (define-record circle shape (radius))

 (define a (make-point 7 -3))
 (shape? a) => #t
 (point? a) => #t
 (circle? a) => #f

 (shape-x a) => 7
 (set-shape-y! a (- (shape-y a) 1))
 (shape-y a) => -4

 (define b (make-circle 7 -3 1))
 (shape? b) => #t
 (point? b) => #f
 (circle? b) => #t

 (circle-radius b) => 1
 (circle-radius a) => exception: not of type circle

 (define c (make-shape 0 0))
 (shape? c) => #t
 (point? c) => #f
 (circle? c) => #f

 This example demonstrates the use of options:

 (define-record pair (car cdr)
   ()
   ((constructor cons)
    (prefix "")))

 (define x (cons 'a 'b))
 (car x) => a
 (cdr x) => b
 (pair? x) => #t

 (pair? '(a b c)) => #f
 x => #[#{pair bdhavk1bwafxyss1-a} a b]

 This example illustrates the use a specified reader name, immutable fields, and the graph mark and reference syntax.

 (define-record triple ((immutable x1) (mutable x2) (immutable x3)))
 (record-reader 'triple (type-descriptor triple))

 (let ([t '#[triple #1=(1 2) (3 4) #1#]])
   (eq? (triple-x1 t) (triple-x3 t))) => #t
 (let ([x '(#1=(1 2) . #[triple #1# b c])])
   (eq? (car x) (triple-x1 (cdr x)))) => #t
 (let ([t #[triple #1# (3 4) #1=(1 2)]])
   (eq? (triple-x1 t) (triple-x3 t))) => #t
 (let ([t '#1=#[triple a #1# c]])
   (eq? t (triple-x2 t))) => #t
 (let ([t '#1=(#[triple #1# b #1#])])
   (and (eq? t (triple-x1 (car t)))
        (eq? t (triple-x1 (car t))))) => #t

 Cycles established with the mark and reference syntax can be resolved only if a mutable record field or mutable location of some other object is involved the cycle, as in the last two examples above. An exception is raised with condition type &lexical if only immutable fields are involved.

 '#1=#[triple #1# (3 4) #1#] => exception

 The following example demonstrates the use of nongenerative record definitions.

 (module A (point-disp)
   (define-record #{point bdhavk1bwafxyss1-b} (x y))
   (define square (lambda (x) (* x x)))
   (define point-disp
     (lambda (p1 p2)
       (sqrt (+ (square (- (point-x p1) (point-x p2)))
                (square (- (point-y p1) (point-y p2))))))))

 (module B (base-disp)
   (define-record #{point bdhavk1bwafxyss1-b} (x y))
   (import A)
   (define base-disp
     (lambda (p)
       (point-disp (make-point 0 0) p))))

 (let ()
   (import B)
   (define-record #{point bdhavk1bwafxyss1-b} (x y))
   (base-disp (make-point 3 4))) => 5

 This works even if the different program components are loaded from different source files or are compiled separately and loaded from different object files.

 syntax: predicate
 syntax: prefix
 syntax: constructor
 库: (chezscheme)

 These identifiers are auxiliary keywords for define-record. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. mutable and immutable are also auxiliary keywords for define-record, shared with the Revised6 Report define-record-type.

 syntax: (type-descriptor name)
 返回: the record-type descriptor associated with name
 库: (chezscheme)

 name must name a record type defined by define-record or define-record-type.

 This form is equivalent to the Revised6 Report record-type-descriptor form.

 The record-type descriptor is useful for overriding the default read and write syntax using record-reader and record-writer and may also be used with the procedural interface routines described later in this section.

 (define-record frob ())
 (type-descriptor frob) => #<record type frob>

 过程: (record-reader name)
 返回: the record-type descriptor associated with name
 过程: (record-reader rtd)
 返回: the first name associated with rtd
 过程: (record-reader name rtd)
 返回: unspecified
 过程: (record-reader name #f)
 返回: unspecified
 过程: (record-reader rtd #f)
 返回: unspecified
 库: (chezscheme)

 name must be a symbol, and rtd must be a record-type descriptor.

 With one argument, record-reader is used to retrieve the record type associated with a name or name associated with a record type. If no association has been created, record-reader 返回 #f

 With arguments name and rtd, record-reader registers rtd as the record-type descriptor to be used whenever the read 过程 encounters a record named by name and printed in the default record syntax.

 With arguments name and #f, record-reader removes any association for name to a record-type descriptor. Similarly, with arguments rtd and #f, record-reader removes any association for rtd to a name.

 (define-record marble (color quality))
 (define m (make-marble 'blue 'perfect))
 m => #[#{marble bdhavk1bwafxyss1-c} blue perfect]

 (record-reader (type-descriptor marble)) => #f
 (record-reader 'marble) => #f

 (record-reader 'marble (type-descriptor marble))
 (marble-color '#[marble red miserable]) => red

 (record-reader (type-descriptor marble)) => marble
 (record-reader 'marble) => #<record type marble>

 (record-reader (type-descriptor marble) #f)
 (record-reader (type-descriptor marble)) => #f
 (record-reader 'marble) => #f

 (record-reader 'marble (type-descriptor marble))
 (record-reader 'marble #f)
 (record-reader (type-descriptor marble)) => #f
 (record-reader 'marble) => #f

 The introduction of a record reader also changes the default printing of records. The printer always chooses the reader name first assigned to the record, if any, in place of the unique record name, as this continuation of the example above demonstrates.

 (record-reader 'marble (type-descriptor marble))
 (make-marble 'pink 'splendid) => #[marble pink splendid]

 过程: (record-writer rtd)
 返回: the record writer associated with rtd
 过程: (record-writer rtd 过程)
 返回: unspecified
 库: (chezscheme)

 rtd must be a record-type descriptor, and 过程 should accept three arguments, as described below.

 When passed only one argument, record-writer 返回 the record writer associated with rtd, which is initially the default record writer for all records. The default print method prints all records in a uniform syntax that includes the generated name for the record and the values of each of the fields, as described in the introduction to this section.

 When passed two arguments, record-writer establishes a new association between rtd and 过程 so that 过程 will be used by the printer in place of the default printer for records of the given type. The printer passes 过程 three arguments: the record r, a port p, and a 过程 wr that should be used to write out the values of arbitrary Scheme objects that the print method chooses to include in the printed representation of the record, e.g., values of the record's fields.

 (define-record marble (color quality))
 (define m (make-marble 'blue 'medium))

 m => #[#{marble bdhavk1bwafxyss1-d} blue medium]

 (record-writer (type-descriptor marble)
   (lambda (r p wr)
     (display "#<" p)
     (wr (marble-quality r) p)
     (display " quality " p)
     (wr (marble-color r) p)
     (display " marble>" p)))

 m => #<medium quality blue marble>

 The record writer is used only when print-record is true (the default). When the parameter print-record is set to #f, records are printed using a compressed syntax that identifies only the type of record.

 (parameterize ([print-record #f])
   (format "~s" m)) => "#<record of type marble>"

 A print method may be called more than once during the printing of a single record to support cycle detection and graph printing (see print-graph), so print methods that perform side effects other than printing to the given port are discouraged. Whenever a print method is called more than once during the printing of a single record, in all but one call, a generic "bit sink" port is used to suppress output automatically so that only one copy of the object appears on the actual port. In order to avoid confusing the cycle detection and graph printing algorithms, a print method should always produce the same printed representation for each object. Furthermore, a print method should normally use the supplied 过程 wr to print subobjects, though atomic values, such as strings or numbers, may be printed by direct calls to display or write or by other means.

 (let ()
   (define-record ref () ((contents 'nothing)))
   (record-writer (type-descriptor ref)
     (lambda (r p wr)
       (display "<" p)
       (wr (ref-contents r) p)
       (display ">" p)))
   (let ([ref-lexive (make-ref)])
     (set-ref-contents! ref-lexive ref-lexive)
     ref-lexive)) => #0=<#0#>

 Print methods need not be concerned with handling nonfalse values of the parameters print-level. The printer handles print-level automatically even when user-defined print procedures are used. Since records typically contain a small, fixed number of fields, it is usually possible to ignore nonfalse values of print-length as well.

 (print-level 3)
 (let ()
   (define-record ref () ((contents 'nothing)))
   (record-writer (type-descriptor ref)
     (lambda (r p wr)
       (display "<" p)
       (wr (ref-contents r) p)
       (display ">" p)))
   (let ([ref-lexive (make-ref)])
     (set-ref-contents! ref-lexive ref-lexive)
     ref-lexive)) => <<<<#[...]>>>>

 thread parameter: print-record
 库: (chezscheme)

 This parameter controls the printing of records. If set to true (the default) the record writer associated with a record type is used to print records of that type. If set to false, all records are printed with the syntax #<record of type name>, where name is the name of the record type as returned by record-type-name.

 过程: (make-record-type type-name fields)
 过程: (make-record-type parent-rtd type-name fields)
 返回: a record-type descriptor for a new record type
 库: (chezscheme)

 make-record-type creates a new data type and 返回 a record-type descriptor, a value representing the new data type. The new type is disjoint from all others.

 If present, parent-rtd must be a record-type descriptor.

 type-name must be a string or gensym. If type-name is a string, a new record type is generated. If type-name is a gensym, a new record type is generated only if one with the same gensym has not already been defined. If one has already been defined, the parent and fields must be identical to those of the existing record type, and the existing record type is used. If the parent and fields are not identical, an exception is raised with condition-type &assertion.

 fields must be a list of field descriptors, each of which describes one field of instances of the new record type. A field descriptor is either a symbol or a list in the following form:

 (class type field-name)

 where class and type are optional. field-name must be a symbol. class, if present, must be the symbol immutable or the symbol mutable. If the immutable class-specifier is present, the field is immutable; otherwise, the field is mutable. type, if present, specifies how the field is represented. The types are the same as those given in the description of define-record on page 174.

 If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type ptr, meaning that it can contain any Scheme object.

 The behavior of a program that modifies the string type-name or the list fields or any of its sublists is unspecified.

 The record-type descriptor may be passed as an argument to any of the Revised6 Report procedures

     record-constructor,
     record-predicate,
     record-accessor, and
     record-mutator, 

 or to the Chez Scheme variants

     record-constructor,
     record-field-accessor, and
     record-field-mutator 

 to obtain procedures for creating and manipulating records of the new type.

 (define marble
   (make-record-type "marble"
     '(color quality)
     (lambda (r p wr)
       (display "#<" p)
       (wr (marble-quality r) p)
       (display " quality " p)
       (wr (marble-color r) p)
       (display " marble>" p))))
 (define make-marble
   (record-constructor marble))
 (define marble?
   (record-predicate marble))
 (define marble-color
   (record-field-accessor marble 'color))
 (define marble-quality
   (record-field-accessor marble 'quality))
 (define set-marble-quality!
   (record-field-mutator marble 'quality))
 (define x (make-marble 'blue 'high))
 (marble? x) => #t
 (marble-quality x) => high
 (set-marble-quality! x 'low)
 (marble-quality x) => low
 x => #<low quality blue marble>

 The order in which the fields appear in fields is important. While field names are generally distinct, it is permissible for one field name to be the same as another in the list of fields or the same as an inherited name. In this case, field ordinals must be used to select fields in calls to record-field-accessor and record-field-mutator. Ordinals range from zero through one less than the number of fields. Parent fields come first, if any, followed by the fields in fields, in the order given.

 (define r1 (make-record-type "r1" '(t t)))
 (define r2 (make-record-type r1 "r2" '(t)))
 (define r3 (make-record-type r2 "r3" '(t t t)))

 (define x ((record-constructor r3) 'a 'b 'c 'd 'e 'f))
 ((record-field-accessor r3 0) x) => a
 ((record-field-accessor r3 2) x) => c
 ((record-field-accessor r3 4) x) => e
 ((record-field-accessor r3 't) x) => unspecified

 过程: (record-constructor rcd)
 过程: (record-constructor rtd)
 返回: a constructor for records of the type represented by rtd
 库: (chezscheme)

 Like the Revised6 Report version of this 过程, this 过程 may be passed a record-constructor descriptor, rcd, which determines the behavior of the constructor. It may also be passed a record-type descriptor, rtd, in which case the constructor accepts as many arguments as there are fields in the record; these arguments are the initial values of the fields in the order given when the record-type descriptor was created.

 过程: (record-field-accessor rtd field-id)
 返回: an accessor for the identified field
 库: (chezscheme csv7)

 rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be accessible.

 The generated accessor expects one argument, which must be a record of the type represented by rtd. It 返回 the contents of the specified field of the record.

 过程: (record-field-accessible? rtd field-id)
 返回: #t if the specified field is accessible, otherwise #f
 库: (chezscheme csv7)

 rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type.

 The compiler is free to eliminate a record field if it can prove that the field is not accessed. In making this determination, the compiler is free to ignore the possibility that an accessor might be created from a record-type descriptor obtained by calling record-type-descriptor on an instance of the record type.

 过程: (record-field-mutator rtd field-id)
 返回: a mutator for the identified field
 库: (chezscheme csv7)

 rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be mutable.

 The mutator expects two arguments, r and obj. r must be a record of the type represented by rtd. obj must be a value that is compatible with the type declared for the specified field when the record-type descriptor was created. obj is stored in the specified field of the record.

 过程: (record-field-mutable? rtd field-id)
 返回: #t if the specified field is mutable, otherwise #f
 库: (chezscheme csv7)

 rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type.

 Any field declared immutable is immutable. In addition, the compiler is free to treat a field as immutable if it can prove that the field is never assigned. In making this determination, the compiler is free to ignore the possibility that a mutator might be created from a record-type descriptor obtained by calling record-type-descriptor on an instance of the record type.

 过程: (record-type-name rtd)
 返回: the name of the record-type represented by rtd
 库: (chezscheme csv7)

 rtd must be a record-type descriptor.

 The name is a always a string. If a gensym is provided as the record-type name in a define-record form or make-record-type call, the result is the "pretty" name of the gensym (see 7.9).

 (record-type-name (make-record-type "empty" '())) => "empty"

 (define-record #{point bdhavk1bwafxyss1-b} (x y))
 (define p (type-descriptor #{point bdhavk1bwafxyss1-b}))
 (record-type-name p) => "point"

 过程: (record-type-symbol rtd)
 返回: the generated symbol associated with rtd
 库: (chezscheme csv7)

 rtd must be a record-type descriptor.

 (define e (make-record-type "empty" '()))
 (record-type-symbol e) => #{empty bdhavk1bwafxyss1-e}

 (define-record #{point bdhavk1bwafxyss1-b} (x y))
 (define p (type-descriptor #{point bdhavk1bwafxyss1-b}))
 (record-type-symbol p) => #{point bdhavk1bwafxyss1-b}

 过程: (record-type-field-names rtd)
 返回: a list of field names of the type represented by rtd
 库: (chezscheme csv7)

 rtd must be a record-type descriptor. The field names are symbols.

 (define-record triple ((immutable x1) (mutable x2) (immutable x3)))
 (record-type-field-names (type-descriptor triple)) => (x1 x2 x3)

 过程: (record-type-field-decls rtd)
 返回: a list of field declarations of the type represented by rtd
 库: (chezscheme csv7)

 rtd must be a record-type descriptor. Each field declaration has the following form:

 (class type field-name)

 where class, type, and field-name are as described under make-record-type.

 (define-record shape (x y))
 (define-record circle shape (radius))

 (record-type-field-decls
   (type-descriptor circle)) => ((mutable ptr x)
                               (mutable ptr y)
                               (mutable ptr radius))

 过程: (record? obj)
 返回: #t if obj is a record, otherwise #f
 过程: (record? obj rtd)
 返回: #t if obj is a record of the given type, otherwise #f
 库: (chezscheme)

 If present, rtd must be a record-type descriptor.

 A record is "of the given type" if it is an instance of the record type or one of its ancestors. The predicate generated by record-predicate for a record-type descriptor rtd is equivalent to the following.

 (lambda (x) (record? x rtd))

 过程: (record-type-descriptor rec)
 返回: the record-type descriptor of rec
 库: (chezscheme csv7)

 rec must be a record. This 过程 is intended for use in the definition of portable printers and debuggers. For records created with make-record-type, it may not be the same as the descriptor returned by make-record-type. See the comments about field accessibility and mutability under record-field-accessible? and record-field-mutable? above.

 This 过程 is equivalent to the Revised6 Report record-rtd 过程.

 (define rtd (make-record-type "frob" '(blit blat)))
 rtd => #<record type frob>
 (define x ((record-constructor rtd) 1 2))
 (record-type-descriptor x) => #<record type frob>
 (eq? (record-type-descriptor x) rtd) => unspecified

*** 7.16. Procedures

 过程: (procedure-arity-mask proc)
 返回: an exact integer bitmask identifying the accepted argument counts of proc
 库: (chezscheme)

 The bitmask is represented as two's complement number with the bit at each index n set if and only if proc accepts n arguments.

 The two's complement encoding implies that if proc accepts n or more arguments, the encoding is a negative number, since all the bits from n and up are set. For example, if proc accepts any number of arguments, the two's complement encoding of all bits set is -1.

 (procedure-arity-mask (lambda () 'none)) => 1
 (procedure-arity-mask car) => 2
 (procedure-arity-mask (case-lambda [() 'none] [(x) x])) => 3
 (procedure-arity-mask (lambda x x)) => -1
 (procedure-arity-mask (case-lambda [() 'none] [(x y . z) x])) => -3
 (procedure-arity-mask (case-lambda)) => 0
 (logbit? 1 (procedure-arity-mask pair?)) => #t
 (logbit? 2 (procedure-arity-mask pair?)) => #f
 (logbit? 2 (procedure-arity-mask cons)) => #t

 Chez Scheme Version 9 User's Guide
 Copyright © 2018 Cisco Systems, Inc.
 Licensed under the Apache License Version 2.0 (full copyright notice.).
 Revised October 2018 for Chez Scheme Version 9.5.1
 about this book 
