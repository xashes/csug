#+OPTIONS: toc:nil

* 7. 对象操作

本章介绍了 /Chez Scheme/ 中针对非数值对象的特定操作，包括 pairs, numbers 等标准对象，以及 boxes, records 等 /Chez Scheme/ 扩展对象。第 8 章介绍了针对数字的操作。关于对象的标准操作的更多描述，参见“The Scheme Programming Language，第 4 版”的第 6 章，或 Scheme 第 6 修订版的报告。

*** 7.1. R6RS 中缺少的类型判断

 过程: (enum-set? obj)

 返回: 如果 ~obj~ 为 =enum set= 则为 =#t=, 否则为 =#f=. 

 库: (chezscheme)

 此一谓词应当被定义，但缺失于第 6 修订版中。


 过程: (record-constructor-descriptor? obj)

 返回: 如果 ~obj~ 为 =record constructor= 则为 =#t=, 否则为 =#f=.

 库: (chezscheme)

 此一谓词应当被定义，但缺失于第 6 修订版中。


*** 7.2. 点对和列表 (Pair and List)

 过程: (atom? obj)

 返回: 如果 ~obj~ 不是点对，则为 =#t=, 否则为 =#f=.

 库: (chezscheme)

 atom? 等价于 (lambda (x) (not (pair? x))).

 #+BEGIN_SRC scheme
   (atom? '(a b c)) => #f
   (atom? '(3 . 4)) => #f
   (atom? '()) => #t
   (atom? 3) => #t
 #+END_SRC

 过程: (list-head list n)

 返回: 列表前 n 个元素的列表

 库: (chezscheme)

 n 须为一精确非负整数，且小于或等于列表的长度。

 ~list-head~ 可以和另一个 Scheme 标准过程 ~list-tail~ 配合，用于将一个列表分割成两个单独的列表。不过， ~list-tail~
 并不进行空间分配，只是返回原列表的子列表，而 ~list-head~ 则总是返回原列表前面部分的一份拷贝。

 ~list-head~ 可依如下定义：

 #+BEGIN_SRC scheme
   (define list-head
     (lambda (ls n)
       (if (= n 0)
           '()
           (cons (car ls) (list-head (cdr ls) (- n 1))))))

   (list-head '(a b c) 0) => ()
   (list-head '(a b c) 2) => (a b)
   (list-head '(a b c) 3) => (a b c)
   (list-head '(a b c . d) 2) => (a b)
   (list-head '(a b c . d) 3) => (a b c)
   (list-head '#1=(a . #1#) 5) => (a a a a a)
 #+END_SRC

 过程: (last-pair list)

 返回: 列表的最后一个点对

 库: (chezscheme)

 列表不可为空。 ~last-pair~ 返回列表的最后一个点对（不是最后一个元素）。列表可以是一个不严格的列表（improper list），此时，最后一个点对为一个包含最末元素和结束对象的点对。

 #+BEGIN_SRC scheme
   (last-pair '(a b c d)) => (d)
   (last-pair '(a b c . d)) => (c . d)
 #+END_SRC

 过程: (list-copy list)

 返回: 列表的一份拷贝

 库: (chezscheme)

 ~list-copy~ 返回与列表相等( ~equal?~ )的一个列表，使用新的点对重新构成顶层的列表结构。

 #+BEGIN_SRC scheme
   (list-copy '(a b c)) => (a b c)

   (let ([ls '(a b c)])
     (equal? ls (list-copy ls))) => #t

   (let ([ls '(a b c)])
     (let ([ls-copy (list-copy ls)])
       (or (eq? ls-copy ls)
           (eq? (cdr ls-copy) (cdr ls))
           (eq? (cddr ls-copy) (cddr ls))))) => #f
 #+END_SRC

 过程: (list* obj ... final-obj)

 返回: 由 ~obj ...~ 组成的列表，结束于 ~final-obj~

 库: (chezscheme)

 ~list*~ 和第 6 修订版中的 ~cons*~ 是一样的。

 过程: (make-list n)

 过程: (make-list n obj)

 返回: n 个对象的列表

 库: (chezscheme)

 n 须为非负整数。如果省略 obj，则列表的元素为未指定的。

 #+BEGIN_SRC scheme
   (make-list 0 '()) => ()
   (make-list 3 0) => (0 0 0)
   (make-list 2 "hi") => ("hi" "hi")
 #+END_SRC

 过程: (iota n)

 返回: 从 0（包含）到 n（不包含）的整数列表

 库: (chezscheme)

 n 须为精确的非负整数。

 #+BEGIN_SRC scheme
   (iota 0) => ()
   (iota 5) => (0 1 2 3 4)
 #+END_SRC

 过程: (enumerate ls)

 返回: 从 0（包含）到长度 ls（不包含）的整数列表。

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (enumerate '()) => ()
   (enumerate '(a b c)) => (0 1 2)
   (let ([ls '(a b c)])
     (map cons ls (enumerate ls))) => ((a . 0) (b . 1) (c . 2))
 #+END_SRC


 过程: (remq! obj list)

 过程: (remv! obj list)

 过程: (remove! obj list)

 返回: 列表中所有 ~obj~ 都被移除后的列表

 库: (chezscheme)

 这些过程与第 6 修订版中的 ~remq~, ~remv~, 及 ~remove~ 过程类似，只是 ~remq!~, ~remv!~ 和 ~remove!~ 使用输入列表中的点对来构成输出列表。它们进行较少的空间分配，但并不一定比它们非破坏性的相应版本更快。如果滥用，很容易导致混乱或错误的结果。

 #+BEGIN_SRC scheme
   (remq! 'a '(a b a c a d)) => (b c d)
   (remv! #\a '(#\a #\b #\c)) => (#\b #\c)
   (remove! '(c) '((a) (b) (c))) => ((a) (b))
 #+END_SRC


 过程: (substq new old tree)

 过程: (substv new old tree)

 过程: (subst new old tree)

 过程: (substq! new old tree)

 过程: (substv! new old tree)

 过程: (subst! new old tree)

 返回: old 被替换为 new 后的树

 库: (chezscheme)

 这些过程遍历树，以对象 new 替换树中所有与对象 old 相等的对象。

 对于 ~substq~ 和 ~substq!~ ，相等性测试是基于 ~eq?~ , ~substv~ 和 ~substv!~ 是基于 ~eqv?~, 而 ~subst~ 和 ~subst!~ 是基于 ~equal?~.

 ~substq!~, ~substv!~, 和 ~subst!~ 执行破坏性的替换。它们进行较少的空间分配，但并不一定比它们非破坏性的对应版本更快。如果滥用，很容易导致混乱或错误的结果。

 #+BEGIN_SRC scheme
   (substq 'a 'b '((b c) b a)) => ((a c) a a)

   (substv 2 1 '((1 . 2) (1 . 4) . 1)) => ((2 . 2) (2 . 4) . 2)

   (subst 'a
          '(a . b)
          '((a . b) (c a . b) . c)) => (a (c . a) . c)

   (let ([tr '((b c) b a)])
     (substq! 'a 'b tr)
     tr) => ((a c) a a)
 #+END_SRC


 过程: (reverse! list)

 返回: 对原列表反向排序的列表

 库: (chezscheme)

 ~reverse!~ 通过反转其链接破坏性地反向排序列表。以 ~reverse!~ 取代 ~reverse~ 减少了空间分配，但并不一定比使用 ~reverse~ 更快。如果滥用，会很容易导致混乱或错误的结果。

 #+BEGIN_SRC scheme
   (reverse! '()) => ()
   (reverse! '(a b c)) => (c b a)

   (let ([x '(a b c)])
     (reverse! x)
     x) => (a)

   (let ([x '(a b c)])
     (set! x (reverse! x))
     x) => (c b a)
 #+END_SRC


 过程: (append! list ...)

 返回: 输入列表的串联

 库: (chezscheme)

 如同 ~append~, ~append!~ 返回一个新的列表，其中元素依次为第一个列表中的元素，第二个列表中的元素，第三个列表中的元素，等等。不同之处在于， ~append!~ 重用所有参数中的点对以构造新列表。即，每一个列表参数的最后一个 ~cdr~, 其后一元素变为指向下一个列表参数。除最后一个参数外，如果任一参数为空列表，它实质上会被忽略。最后一个参数（并不一定得是列表）是不变的。

 相比于 ~append~, ~append!~ 进行更少的空间分配，但并不一定更快。如果滥用，会很容易导致混乱或错误的结果。

 #+BEGIN_SRC scheme
   (append! '(a b) '(c d)) => (a b c d)

   (let ([x '(a b)])
     (append! x '(c d))
     x) => (a b c d)
 #+END_SRC


*** 7.3. 字符 (Characters)

 /Chez Scheme/ 以两种方式扩展了字符的句法。其一，前缀 ~#\~ 后面紧跟 3 位八进制数字会被读取为一个字符，其数字编码即为此 3 位数的八进制值，例如， ~#\044~ 被读取为 ~#\$~. 其二，它可以识别若干非标准命名的字符： ~#\rubout~ (等同于 ~#\delete~)， ~#\bel~ (等同于 ~#\alarm~), ~#\vt~ (等同于 ~#\vtab~), ~#\nel~ (Unicode NEL 字符), 以及 ~#\ls~ (Unicode LS 字符). 非标准字符的名字可以通过过程 ~char-name~ 更改（参见 9.14 节）。

 读取器若遇到 ~#!r6rs~ ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 ~#!chezscheme~.

 过程: (char=? char1 char2 ...)

 过程: (char<? char1 char2 ...)

 过程: (char>? char1 char2 ...)

 过程: (char<=? char1 char2 ...)

 过程: (char>=? char1 char2 ...)

 过程: (char-ci=? char1 char2 ...)

 过程: (char-ci<? char1 char2 ...)

 过程: (char-ci>? char1 char2 ...)

 过程: (char-ci<=? char1 char2 ...)

 过程: (char-ci>=? char1 char2 ...)

 返回: 如果关系成立，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 这些谓词与第 6 修订版中的对应版本是一样的，只是被扩展为接受一个以上参数，而非两个以上参数。当只传入一个参数时，这些谓词均返回 ~#t~.

 #+BEGIN_SRC scheme
   (char>? #\a) => #t
   (char<? #\a) => #t
   (char-ci=? #\a) => #t
 #+END_SRC

 过程: (char- char1 char2)

 返回: ~char1~ 和 ~char2~ 间的整数差值

 库: (chezscheme)

 ~char-~ 以 ~char1~ 的整数值减去 ~char2~ 的整数值，并返回差值。后面的例子假设以字符的 ASCII 码作为其整数表示。

 #+BEGIN_SRC scheme
   (char- #\f #\e) => 1

   (define digit-value
     ; 根据基数 r 返回数字 c 的值，
     ; 如果 c 不是有效的数字，则返回 #f
     (lambda (c r)
       (let ([v (cond
                 [(char<=? #\0 c #\9) (char- c #\0)]
                 [(char<=? #\A c #\Z) (char- c #\7)]
                 [(char<=? #\a c #\z) (char- c #\W)]
                 [else 36])])
         (and (fx< v r) v))))
   (digit-value #\8 10) => 8
   (digit-value #\z 10) => #f
   (digit-value #\z 36) => 35
 #+END_SRC

 ~char-~ 可依如下定义。
 
 #+BEGIN_SRC scheme
   (define char-
     (lambda (c1 c2)
       (- (char->integer c1) (char->integer c2))))
 #+END_SRC


*** 7.4. 字符串 (Strings)

 基于标准的字符串句法， /Chez Scheme/ 增加了两种转义字符： ~\'~ 生成单引号字符，以及 ~\nnn~, 即，反斜杠紧跟着 3 位 8 进制数，生成等同于此 3 位 8 进制数的值的字符。读取器若遇到 ~#!r6rs~ ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 ~#!chezscheme~.

 所有字符串默认是可变的，包括常量。程序可以通过 ~string->immutable-string~ 创建不可变字符串。尝试修改不可变字符串会导致抛出异常。

 在 /Chez Scheme/ 中，字符串的长度和索引总是定长数。

 过程: (string=? string1 string2 string3 ...)

 过程: (string<? string1 string2 string3 ...)

 过程: (string>? string1 string2 string3 ...)

 过程: (string<=? string1 string2 string3 ...)

 过程: (string>=? string1 string2 string3 ...)

 过程: (string-ci=? string1 string2 string3 ...)

 过程: (string-ci<? string1 string2 string3 ...)

 过程: (string-ci>? string1 string2 string3 ...)

 过程: (string-ci<=? string1 string2 string3 ...)

 过程: (string-ci>=? string1 string2 string3 ...)

 返回: 如果关系成立，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 这些谓词与第 6 修订版中的对应版本是一样的，只是被扩展为接受一个以上参数，而非两个以上参数。当只传入一个参数时，这些谓词均返回 ~#t~.

 #+BEGIN_SRC scheme
   (string>? "a") => #t
   (string<? "a") => #t
   (string-ci=? "a") => #t
 #+END_SRC


 过程: (string-copy! src src-start dst dst-start n)

 返回: 未定义

 库: (chezscheme)

 ~src~ 和 ~dst~ 必须是字符串，且 ~dst~ 必须可变。 ~src-start~, ~dst-start~, 以及 ~n~ 必须是精确的非负整数。 ~src-start~ 和 ~n~ 的和绝对不能超过 ~src~ 的长度， 而 ~dst-start~ 和 ~n~ 的和则一定不能超过 ~dst~ 的长度。

 ~string-copy!~ 以 ~src~ 中起始于 ~src-start~ ，长度为 ~n~ 字节的部分，覆盖 ~dst~ 中起始于 ~dst-start~ ，长度为 ~n~ 字节的部分。即使 ~dst~ 和 ~src~ 是同一个字符串，且源和目标位置相互重叠，这个操作也能生效。即，在操作开始时，目标位置先被源字符串中的字符填充。

 #+BEGIN_SRC scheme
   (define s1 "to boldly go")
   (define s2 (make-string 10 #\-))

   (string-copy! s1 3 s2 1 3)
   s2 => "-bol------"

   (string-copy! s1 7 s2 4 2)
   s2 => "-bolly----"

   (string-copy! s2 2 s2 5 4)
   s2 => "-bollolly-"
 #+END_SRC


 过程: (substring-fill! string start end char)

 返回: 未定义

 库: (chezscheme)

 ~string~ 必须是可变的。 ~string~ 于 ~start~ (包含) 和 ~end~ (不包含) 之间的字符均被设置为 ~char~. ~start~ 和 ~end~ 必须是非负整数； ~start~ 必须严格小于 ~string~ 的长度，而 ~end~ 可以小于或等于 ~string~ 的长度。如果 =end ≤ start=, 则字符串保持不变。

 #+BEGIN_SRC scheme
   (let ([str (string-copy "a tpyo typo")])
     (substring-fill! str 2 6 #\X)
     str) => "a XXXX typo"
 #+END_SRC


 过程: (string-truncate! string n)

 返回: 字符串或空字符串

 库: (chezscheme)

 ~string~ 必须是可变的。 ~n~ 必须是精确的非负定长数，且不大于 ~string~ 的长度。如果 ~n~ 是 0, ~string-truncate!~ 返回空字符串。否则， ~string-truncate!~ 破坏性地把 ~string~ 缩短为其前 ~n~ 个字符，并返回 ~string~.

 #+BEGIN_SRC scheme
   (define s (make-string 7 #\$))
   (string-truncate! s 0) => ""
   s => "$$$$$$$"
   (string-truncate! s 3) => "$$$"
   s => "$$$"
 #+END_SRC


 过程: (mutable-string? obj)

 返回: 如果 ~obj~ 是可变字符串，则为 ~#t~, 否则为 ~#f~.

 过程: (immutable-string? obj)

 返回: 如果 ~obj~ 是不可变字符串，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (mutable-string? (string #\a #\b #\c)) => #t
   (mutable-string? (string->immutable-string "abc")) => #f
   (immutable-string? (string #\a #\b #\c)) => #f
   (immutable-string? (string->immutable-string "abc")) => #t
   (immutable-string? (cons 3 4)) => #f
 #+END_SRC


 过程: (string->immutable-string string)

 返回: 与 ~string~ 相等(equal)的不可变字符串

 库: (chezscheme)

 如果 ~string~ 是不可变字符串，则结果为其本身；否则，结果是个不可变字符串，其内容与 ~string~ 相同。

 #+BEGIN_SRC scheme 
   (define s (string->immutable-string (string #\x #\y #\z)))
   (string-set! s 0 #\a) => exception: not mutable
 #+END_SRC


*** 7.5. 向量 (Vectors)
 /Chez Scheme/ 扩展了向量的句法，以允许在 ~#~ 和左括号之间指定向量的长度，形如， ~#3(a b c)~. 如果在此语法形式下提供的向量元素比指定的长度要少，则之后的每个元素都与最后一个提供的元素相同。读取器若遇到 ~#!r6rs~ ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 ~#!chezscheme~.

 在 /Chez Scheme/ 中，向量的长度和索引总是定长数。

 所有向量默认都是可变的，包括常量。程序可以通过 ~vector->immutable-vector~ 创建不可变向量。尝试修改不可变向量会导致抛出异常。

 过程: (vector-copy vector)

 返回: ~vector~ 的一份拷贝

 库: (chezscheme)

 ~vector-copy~ 生成一个长度和内容都和 ~vector~ 相同的新向量。里面的元素本身不是被复制的。

 #+BEGIN_SRC scheme
   (vector-copy '#(a b c)) => #(a b c)

   (let ([v '#(a b c)])
     (eq? v (vector-copy v))) => #f
 #+END_SRC


 过程: (vector-set-fixnum! vector n fixnum)

 返回: 未定义

 库: (chezscheme)

 ~vector~ 必须是不可变的。 ~vector-set-fixnum!~ 把向量的第 ~n~ 个元素变更为 ~fixnum~. ~n~ 必须是一个确切的非负整数，且严格小于 ~vector~ 的长度。

 储存定长数要比储存任意值快，因为对于任意值，系统需要记录从老到新的各个对象的潜在分配，以支持分代垃圾回收。不过，必须小心确保参数确实是一个定长数；否则，收集器可能无法正确地追踪资源分配。只要不在优化级别 3, 基本过程会对参数进行定长数检验。

 参见后面关于全定长数向量 （fxvectors) 的描述。

 #+BEGIN_SRC scheme
   (let ([v (vector 1 2 3 4 5)])
     (vector-set-fixnum! v 2 73)
     v) => #(1 2 73 4 5)
 #+END_SRC


 过程: (vector-cas! vector n old-obj new-obj)

 返回: 如果 ~vector~ 有改变，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 ~vector~ 必须是可变的。 若 ~vector~ 的第 ~n~ 个元素和 ~old-obj~ 相同（ ~eq?~ ）, 则 ~vector-cas!~ 自动将此元素替换为 ~new-obj~, 若不相同，则 ~vector~ 保持不变。

 #+BEGIN_SRC scheme
   (define v (vector 'old0 'old1 'old2))
   (vector-cas! v 1 'old1 'new1) => #t
   (vector-ref v 1) => 'new1
   (vector-cas! v 2 'old1 'new2) => #f
   (vector-ref v 2) => 'old2
 #+END_SRC


 过程: (mutable-vector? obj)

 返回: 如果 ~obj~ 是可变向量，则为 ~#t~, 否则为 ~#f~.

 过程: (immutable-vector? obj)

 返回: 如果 ~obj~ 是不可变向量，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (mutable-vector? (vector 1 2 3)) => #t
   (mutable-vector? (vector->immutable-vector (vector 1 2 3))) => #f
   (immutable-vector? (vector 1 2 3)) => #f
   (immutable-vector? (vector->immutable-vector (vector 1 2 3))) => #t
   (immutable-vector? (cons 3 4)) => #f
 #+END_SRC


 过程: (vector->immutable-vector vector)

 返回: 与 ~vector~ 相等(equal)的一个不可变向量

 库: (chezscheme)

 如果 ~vector~ 是不可变向量，则结果为其本身；否则，结果是与 ~vector~ 内容相同的一个不可变向量。

 #+BEGIN_SRC scheme
   (define v (vector->immutable-vector (vector 1 2 3)))
   (vector-set! v 0 0) => exception: not mutable
 #+END_SRC


*** 7.6. 定长数向量 (Fixnum-Only Vectors)

 定长数向量, 即 "fxvectors", 类似于向量，但只包含定长数。定长数向量的输出形式以前缀 =#vfx= 替换向量的前缀 =#=, 例如， ~#vfx(1 2 3)~ 或 ~#10vfx(2)~. 读取器若遇到 ~#!r6rs~ ，则会在其后的输入流中禁用定长数向量的句法，除非在更近的位置遇到 ~#!chezscheme~.

 定长数向量的长度和索引总是定长数。

 更新定长数向量通常比更新向量节省资源，因为对于向量来说，系统需要记录从老到新的各个对象的潜在分配，以支持分代垃圾回收。定长数向量不包含要指向内存某一区域的指针，受益于此，存储管理系统不需要在垃圾收集期间对这些指针进行追踪。

 定长数向量默认是可变的，包括常量。程序可以通过 ~fxvector->immutable-fxvector~ 创建不可变的定长数向量。尝试修改一个不可变的定长数向量会导致异常抛出。

 可参考前述的 ~vector-set-fixnum!~.


 过程: (fxvector? obj)

 返回: 如果 ~obj~ 是一个定长数向量，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (fxvector? #vfx()) => #t
   (fxvector? #vfx(1 2 3)) => #t
   (fxvector? (fxvector 1 2 3)) => #t
   (fxvector? '#(a b c)) => #f
   (fxvector? '(a b c)) => #f
   (fxvector? "abc") => #f
 #+END_SRC


 过程: (fxvector fixnum ...)

 返回: 一个由参数中的所有定长数 ~fixnum ...~ 组成的定长数向量

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (fxvector) => #vfx()
   (fxvector 1 3 5) => #vfx(1 3 5)
 #+END_SRC


 过程: (make-fxvector n)

 过程: (make-fxvector n fixnum)

 返回: 一个长度为 ~n~ 的定长数向量

 库: (chezscheme)

 ~n~ 必须是定长数。如果有提供参数 ~fixnum~, 则定长数向量中的每个元素都被初始化为 ~fixnum~; 不然，其中元素则均为未定义。

 #+BEGIN_SRC scheme
   (make-fxvector 0) => #vfx()
   (make-fxvector 0 7) => #vfx()
   (make-fxvector 5 7) => #vfx(7 7 7 7 7)
 #+END_SRC


 过程: (fxvector-length fxvector)

 返回: ~fxvector~ 中的元素个数

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (fxvector-length #vfx()) => 0
   (fxvector-length #vfx(1 2 3)) => 3
   (fxvector-length #10vfx(1 2 3)) => 10
   (fxvector-length (fxvector 1 2 3 4)) => 4
   (fxvector-length (make-fxvector 300)) => 300
 #+END_SRC


 过程: (fxvector-ref fxvector n)

 返回: ~fxvector~ 中的第 ~n~ 个元素 (索引基于 0)

 库: (chezscheme)

 ~n~ 必须是一个非负定长数，且严格小于 ~fxvector~ 的长度。

 #+BEGIN_SRC scheme
   (fxvector-ref #vfx(-1 2 4 7) 0) => -1
   (fxvector-ref #vfx(-1 2 4 7) 1) => 2
   (fxvector-ref #vfx(-1 2 4 7) 3) => 7
 #+END_SRC


 过程: (fxvector-set! fxvector n fixnum)

 返回: 未定义

 库: (chezscheme)

 ~fxvector~ 必须是可变的。 ~n~ 必须是一个非负定长数，且严格小于 ~fxvector~ 的长度。 ~fxvector-set!~ 把 ~fxvector~ 中的第 ~n~ 个元素修改为 ~fixnum~.

 #+BEGIN_SRC scheme
   (let ([v (fxvector 1 2 3 4 5)])
     (fxvector-set! v 2 (fx- (fxvector-ref v 2)))
     v) => #vfx(1 2 -3 4 5)
 #+END_SRC


 过程: (fxvector-fill! fxvector fixnum)

 返回: 未定义

 库: (chezscheme)

 ~fxvector~ 必须是可变的。 ~fxvector-fill!~ 把 ~fxvector~ 中的每个元素替换为 ~fixnum~.

 #+BEGIN_SRC scheme
   (let ([v (fxvector 1 2 3)])
     (fxvector-fill! v 0)
     v) => #vfx(0 0 0)
 #+END_SRC


 过程: (fxvector->list fxvector)

 返回: ~fxvector~ 中所有元素组成的列表

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (fxvector->list (fxvector)) => ()
   (fxvector->list #vfx(7 5 2)) => (7 5 2)

   (let ([v #vfx(1 2 3 4 5)])
     (apply fx* (fxvector->list v))) => 120
 #+END_SRC


 过程: (list->fxvector list)

 返回: ~list~ 中所有元素组成的定长数向量

 库: (chezscheme)

 ~list~ 必须完全由定长数组成。

 #+BEGIN_SRC scheme
   (list->fxvector '()) => #vfx()
   (list->fxvector '(3 5 7)) => #vfx(3 5 7)

   (let ([v #vfx(1 2 3 4 5)])
     (let ([ls (fxvector->list v)])
       (list->fxvector (map fx* ls ls)))) => #vfx(1 4 9 16 25)
 #+END_SRC


 过程: (fxvector-copy fxvector)

 返回: ~fxvector~ 的一份拷贝

 库: (chezscheme)

 ~fxvector-copy~ 生成一个与 ~fxvector~ 长度和内容都一样的新的定长数向量。

 #+BEGIN_SRC scheme
   (fxvector-copy #vfx(3 4 5)) => #vfx(3 4 5)

   (let ([v #vfx(3 4 5)])
     (eq? v (fxvector-copy v))) => #f
 #+END_SRC


 过程: (mutable-fxvector? obj)

 返回: 如果 ~obj~ 是一个可变的定长数向量，则为 ~#t~, 否则为 ~#f~.

 过程: (immutable-fxvector? obj)

 返回: 如果 ~obj~ 是一个不可变的定长数向量，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (mutable-fxvector? (fxvector 1 2 3)) => #t
   (mutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) => #f
   (immutable-fxvector? (fxvector 1 2 3)) => #f
   (immutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) => #t
   (immutable-fxvector? (cons 3 4)) => #f
 #+END_SRC


 过程: (fxvector->immutable-fxvector fxvector)

 返回: ~fxvector~ 的一份不可变的拷贝或其自身

 库: (chezscheme)

 如果 ~fxvector~ 是不可变的，则结果为其本身；否则，结果是与 ~fxvector~ 内容相同的一个不可变定长数向量。

 #+BEGIN_SRC scheme
   (define v (fxvector->immutable-fxvector (fxvector 1 2 3)))
   (fxvector-set! v 0 0) => exception: not mutable
 #+END_SRC


*** 7.7. 字节向量 (Bytevectors)

 如同向量， /Chez Scheme/ 也扩展了字节向量的句法，以允许在 ~#~ 和左括号之间指定向量的长度，例如， ~#3vu8(1 105 73).~ 如果在此语法形式下提供的向量元素比指定的长度要少，则之后的每个元素都与最后一个提供的元素相同。读取器若遇到 ~#!r6rs~ ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 ~#!chezscheme~.

 /Chez Scheme/ 同时扩展了字节向量的基本操作集，包括了加载和存储 3, 5, 6, 7 字节长度的基本操作。

 /Chez Scheme/ 中，字节向量的长度和索引总是定长数。

 字节向量默认是可变的，包括常量。程序可以通过 ~bytevector->immutable-bytevector~ 创建不可变字节向量。尝试修改不可变字节向量会导致抛出异常。


 过程: (bytevector fill ...)

 返回: 一个内容为 ~fill ...~ 的字节向量

 库: (chezscheme)

 每个填充值必须为一个表示 8 位有符号或无符号值的精确整数，即，一个在范围 -128 至 255（两端均包含）之间的值。负的填充值被视为与其等价的补码。

 #+BEGIN_SRC scheme
   (bytevector) => #vu8()
   (bytevector 1 3 5) => #vu8(1 3 5)
   (bytevector -1 -3 -5) => #vu8(255 253 251)
 #+END_SRC


 过程: (bytevector->s8-list bytevector)

 返回: ~bytevector~ 转化成的 8 位有符号数列表

 库: (chezscheme)

 返回列表中的值均为精确的 8 位有符号整数，即，在范围 -128 至 127（两端均包含）之间的值。 ~bytevector->s8-list~ 与第 6 修订版中的 ~bytevector->u8-list~ 相似，只是返回列表中的值是有符号数，而非无符号数。

 #+BEGIN_SRC scheme
   (bytevector->s8-list (make-bytevector 0)) => ()
   (bytevector->s8-list #vu8(1 127 128 255)) => (1 127 -128 -1)

   (let ([v #vu8(1 2 3 255)])
     (apply * (bytevector->s8-list v))) => -6
 #+END_SRC


 过程: (s8-list->bytevector list)

 返回: ~list~ 中的元素组成的新字节向量

 库: (chezscheme)

 ~list~ 必须完全由精确的 8 位有符号整数组成，即，在范围 -128 至 127（两端均包含）之间的值。 ~s8-list->bytevector~ 与第 6 修订版中的过程 ~u8-list->bytevector~ 相似，只是输入列表中的元素是有符号数，而非无符号数。

 #+BEGIN_SRC scheme
   (s8-list->bytevector '()) => #vu8()
   (s8-list->bytevector '(1 127 -128 -1)) => #vu8(1 127 128 255)

   (let ([v #vu8(1 2 3 4 5)])
     (let ([ls (bytevector->s8-list v)])
       (s8-list->bytevector (map - ls)))) => #vu8(255 254 253 252 251)
 #+END_SRC


 过程: (bytevector-truncate! bytevector n)

 返回: ~bytevector~, 或空字节向量

 库: (chezscheme)

 ~bytevector~ 必须是可变的。 ~n~ 必须是一个精确的非负定长数，且不大于 ~bytevector~ 的长度。如果 ~n~ 是 0, ~bytevector-truncate!~ 返回空字节向量，否则， ~bytevector-truncate!~ 破坏性地把 ~bytevector~ 缩短为其前 ~n~ 个字节，并返回 ~bytevector~.

 #+BEGIN_SRC scheme
   (define bv (make-bytevector 7 19))
   (bytevector-truncate! bv 0) => #vu8()
   bv => #vu8(19 19 19 19 19 19 19)
   (bytevector-truncate! bv 3) => #vu8(19 19 19)
   bv => #vu8(19 19 19)
 #+END_SRC


 过程: (bytevector-u24-ref bytevector n eness)
 
 返回: ~bytevector~ 的索引 ~n~ (始于 0) 处的 24 位无符号整数

 过程: (bytevector-s24-ref bytevector n eness)

 返回: ~bytevector~ 的索引 ~n~ (始于 0) 处的 24 位有符号整数

 过程: (bytevector-u40-ref bytevector n eness)

 返回: ~bytevector~ 的索引 ~n~ (始于 0) 处的 40 位无符号整数

 过程: (bytevector-s40-ref bytevector n eness)

 返回: ~bytevector~ 的索引 ~n~ (始于 0) 处的 40 位有符号整数

 过程: (bytevector-u48-ref bytevector n eness)

 返回: ~bytevector~ 的索引 ~n~ (始于 0) 处的 48 位无符号整数

 过程: (bytevector-s48-ref bytevector n eness)

 返回: ~bytevector~ 的索引 ~n~ (始于 0) 处的 48 位有符号整数

 过程: (bytevector-u56-ref bytevector n eness)

 返回: ~bytevector~ 的索引 ~n~ (始于 0) 处的 56 位无符号整数

 过程: (bytevector-s56-ref bytevector n eness)

 返回: ~bytevector~ 的索引 ~n~ (始于 0) 处的 56 位有符号整数

 库: (chezscheme)

 ~n~ 必须是一个精确的非负整数，并且指示数值的起始字节。 ~n~ 和数值占用的字节之和 (24 位数值为 3 个字节，40 位数值为 5 个字节，48 位数值为 6 个字节，56 位数值为 7 个字节) 一定不能超过 ~bytevector~ 的长度。 ~eness~ 必须是一个命名此字节序(endianness)的有效的字节序符号(symbol)。

 返回值是一个精确整数，根据数值所占用的字节数处于适当的区间。有符号数是作为其补码存储的等价值。

 过程: (bytevector-u24-set! bytevector n u24 eness)

 过程: (bytevector-s24-set! bytevector n s24 eness)

 过程: (bytevector-u40-set! bytevector n u40 eness)

 过程: (bytevector-s40-set! bytevector n s40 eness)

 过程: (bytevector-u48-set! bytevector n u48 eness)

 过程: (bytevector-s48-set! bytevector n s48 eness)

 过程: (bytevector-u56-set! bytevector n u56 eness)

 过程: (bytevector-s56-set! bytevector n s56 eness)

 返回: 未定义

 库: (chezscheme)

 ~bytevector~ 必须是不可变的。 ~n~ 必须是一个精确的非负整数，并且指示数值的起始字节。 ~n~ 和数值占用的字节之和一定不能超过 ~bytevector~ 的长度。 ~u24~ 必须是一个 24 位无符号值，即，在 0 至 2^24 - 1 (两端均包含) 区间中的值； ~s24~ 必须是一个 24 位有符号值，即，在 -2^23 至 2^23 - 1 (两端均包含) 区间中的值； ~u40~ 必须是一个 40 位无符号值，即，在 0 至 2^40 - 1 (两端均包含) 区间中的值； ~s40~ 必须是一个 40 位有符号值，即，在 -2^39 至 2^39 - 1 (两端均包含) 区间中的值； ~u48~ 必须是一个 48 位无符号值，即，在 0 至 2^48 - 1 (两端均包含) 区间中的值； ~s48~ 必须是一个 48 位有符号值，即，在 -2^47 至 2^47 - 1 (两端均包含) 区间中的值； ~u56~ 必须是一个 56 位无符号值，即，在 0 至 2^56 - 1 (两端均包含) 区间中的值； ~s56~ 必须是一个 56 位有符号值，即，在 -2^55 至 2^55 - 1 (两端均包含) 区间中的值。 ~eness~ 必须是一个命名此字节序(endianness)的有效的字节序符号(symbol)。

 这些过程把给定值存储到 ~bytevector~ 的索引 ~n~ (基于 0)处起始的 3, 5, 6, 7 字节中。负值存储为与其等价的补码。

 过程: (mutable-bytevector? obj)

 返回: 如果 ~obj~ 是一个可变的字节向量，则为 ~#t~, 否则为 ~#f~.

 过程: (immutable-bytevector? obj)

 返回: 如果 ~obj~ 是一个不可变的字节向量，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (mutable-bytevector? (bytevector 1 2 3)) => #t
   (mutable-bytevector?
    (bytevector->immutable-bytevector (bytevector 1 2 3))) => #f
   (immutable-bytevector? (bytevector 1 2 3)) => #f
   (immutable-bytevector?
    (bytevector->immutable-bytevector (bytevector 1 2 3))) => #t
   (immutable-bytevector? (cons 3 4)) => #f
 #+END_SRC


 过程: (bytevector->immutable-bytevector bytevector)

 返回: 与 ~bytevector~ 相等(equal)的一个不可变字节向量

 库: (chezscheme)

 如果 ~bytevector~ 是不可变的，则结果为其本身；否则，结果是与 ~bytevector~ 内容相同的一个不可变字节向量。

 #+BEGIN_SRC scheme
   (define bv (bytevector->immutable-bytevector (bytevector 1 2 3)))
   (bytevector-u8-set! bv 0 0) => exception: not mutable
 #+END_SRC


 过程: (bytevector-compress bytevector)

 返回: 一个新的字节向量，包含 ~bytevector~ 压缩后的内容

 库: (chezscheme)

 结果是原始的压缩数据，以最精简的头部信息记录了压缩前的大小和压缩模式。结果并未包含使用压缩选项通过 /port-based/ 压缩所写入的头部信息。

 过程: (bytevector-uncompress bytevector)

 返回: 一个字节向量，包含 ~bytevector~ 解压缩后的内容

 库: (chezscheme)

 把一个由 ~bytevector-compress~ 生成的 ~bytevector~, 解压为一个新的字节向量，其内容与最初传递给 ~bytevector-compress~ 的 字节向量相同。
 

*** 7.8. Boxes

 /Boxes/ 是一种单元素对象，主要用于提供一个“额外的间接层”。这个额外的间接层，通常用于使多个代码块或数据结构可以共享指向一个对象的引用，或指针。例如，在采用此种参数传递规则的语言的解释器中，可以用 /boxes/ 实现 ~call-by-reference~ 的语义。

 /Boxes/ 的字面形式带有前缀 ~#&~ (发音为 "hash-ampersand"). 例如， ~#&(a b c)~ 是一个 /box，内容为列表/ ~(a b c)~. 读取器若遇到 ~#!r6rs~ ，则会在其后的输入流中禁用 /box/ 句法，除非在更近的位置遇到 ~#!chezscheme~.

 所有 /boxes/ 默认是可变的，包括常量。程序可以通过 ~box-immutable~ 创建不可变 /boxes/. 尝试修改不可变 /box/ 会导致抛出异常。

 过程: (box? obj)

 返回: 如果 ~obj~ 是 /box/, 则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (box? '#&a) => #t
   (box? 'a) => #f
   (box? (box 3)) => #t
 #+END_SRC


 过程: (box obj)

 返回: 一个包含 ~obj~ 的新的 /box/

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (box 'a) => #&a
   (box (box '(a b c))) => #&#&(a b c)
 #+END_SRC


 过程: (unbox box)

 返回: ~box~ 的内容

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (unbox #&a) => a
   (unbox #&#&(a b c)) => #&(a b c)

   (let ([b (box "hi")])
     (unbox b)) => "hi"
 #+END_SRC


 过程: (set-box! box obj)

 返回: 未定义

 库: (chezscheme)

 ~box~ 必须是可变的。 ~set-box!~ 把 ~box~ 的内容设置为 ~obj~.

 #+BEGIN_SRC scheme
   (let ([b (box 'x)])
     (set-box! b 'y)
     b) => #&y

   (let ([incr!
          (lambda (x)
            (set-box! x (+ (unbox x) 1)))])
     (let ([b (box 3)])
       (incr! b)
       (unbox b))) => 4
 #+END_SRC


 过程: (box-cas! box old-obj new-obj)

 返回: 如果 ~box~ 被改变，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 ~box~ 必须是可变的。 若 ~box~ 待替换的内容和 ~old-obj~ 相同(基于 ~eq?~), 则 ~box-cas!~ 自动将 ~box~ 的内容替换为 ~new-obj~; 若不相同，则 ~box~ 保持不变。

 #+BEGIN_SRC scheme
   (define b (box 'old))
   (box-cas! b 'old 'new) => #t
   (unbox b) => 'new
   (box-cas! b 'other 'wrong) => #f
   (unbox b) => 'new
 #+END_SRC


 过程: (mutable-box? obj)

 返回: 如果 ~obj~ 是可变的 /box/ ，则为 ~#t~, 否则为 ~#f~.

 过程: (immutable-box? obj)

 返回: 如果 ~obj~ 是不可变的 /box/ ，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (mutable-box? (box 1)) => #t
   (mutable-box? (box-immutable 1)) => #f
   (immutable-box? (box 1)) => #f
   (immutable-box? (box-immutable 1)) => #t
   (mutable-box? (cons 3 4)) => #f
 #+END_SRC


 过程: (box-immutable obj)

 返回: 一个内容为 ~obj~ 的新的不可变 /box/

 库: (chezscheme)

 /Boxes/ 通常用来支持共享的，可变的结构，所以不可变的 /box/ 一般没什么用。

 #+BEGIN_SRC scheme
   (define b (box-immutable 1))
   (set-box! b 0) => exception: not mutable
 #+END_SRC


*** 7.9. 符号 (Symbols)

 /Chez Scheme/ 对标准符号句法进行了多方面的扩展：

     符号名可以以 ~@~ 开始，但是， ~,@abc~ 被解析为 ~(unquote-splicing abc)~; 如果要生成 ~(unquote @abc)~ ，可以键入 ~, @abc~, ~\x40;abc~, 或者 ~,|@abc|~.

     单字符 ~{~ 和 ~}~ 被读取为符号。

     通常作为数字起始的任意字符，可以作为符号名的开头，包括数字， ~.~, ~+~, ~-~, 只要此字符和其后的字符序列总体不会被解析成一个数字就可以。

     名字包含任意字符的符号可以通过转义符 ~\~ 或 ~|~ 来书写。 ~\~ 用来转义单个字符（除了 'x'，因为 ~\x~ 是 16 进制数的起始标记），而 ~|~ 用来转义一组字符，直到配对的 ~|~ 为止。

 printer 总是依标准 R6RS 句法打印符号，所以，如 ~@abc~ 会被打印为 ~\x40;abc~, ~1-~ 会被打印为 ~\x31;-~.

 ~gensym~ 过程族把“美观”版和“唯一”版名字放到 ~#{~ 和 ~}~ 之间打印出来，形如 ~#{g1426 e5g1c94g642dssw-a}~. 它们也可以以前缀 ~#:~ 来只打印美观版名字，如 ~#:g1426~.

 读取器若遇到 ~#!r6rs~ ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 ~#!chezscheme~.

 过程: (gensym)

 过程: (gensym pretty-name)

 过程: (gensym pretty-name unique-name)

 返回: 一个唯一生成的符号

 库: (chezscheme)

 每个 ~gensym~ 调用返回一个唯一生成的符号，或 /gensym/. 每个生成的符号有两个名字：一个“美观”版名字和一个“唯一”版名字。

 In the first form above, the pretty name is formed (lazily---see below) by combining an internal prefix with the value of an internal counter. After each name is formed, the internal counter is incremented. The parameters gensym-prefix and gensym-count, described below, may be used to access and set the internal prefix and counter. By default, the prefix is the single-character string "g". In the second and third forms, the pretty name of the new gensym is pretty-name, which must be a string. The pretty name of a gensym is returned by the 过程 symbol->string.
 在上文的第一个形式中，美观版名字是通过组合一个内部的前缀和一个内部计数器的值来形成（惰性的──参见下文）。在每个名字形成之后，内部计数器会增加。下文将提及的参数 ~gensym-prefix~ 和 ~gensym-count~, 可以用来访问和设置内部前缀和计数器。前缀默认为单字符字符串 ~"g".~ 在第二和第三种形式中，新的生成符号的美观版名字是 ~pretty-name~, 其必须为一字符串。生成符号的美观版名字由过程 ~symbol->string~ 返回。

 In both the first and second forms, the unique name is an automatically generated globally unique name. Globally unique names are constructed (lazily---see below) from the combination of a universally unique identifier and an internal counter. In the third form of gensym, the unique name of the new gensym is unique-name, which must be a string. The unique name of a gensym may be obtained via the 过程 gensym->unique-string.
 在前两种形式中，唯一版名字是一个自动生成的全局唯一名字。全局唯一名字是通过组合一个全局唯一标识符和一个内部计数器来构造的（惰性的──参见下文）。在第三种生成符号的形式中，新生成符号的唯一版名字是 ~unique-name~, 其必须为一字符串。生成符号的唯一版名字可以通过过程 ~gensym->unique-string~ 获得。

 The unique name allows gensyms to be written in such a way that they can be read back and reliably commonized on input. The syntax for gensyms includes both the pretty name and the unique name, as shown in the example below:

 #+BEGIN_SRC scheme
   (gensym) => #{g0 bcsfg5eq4e9b3h9o-a}
 #+END_SRC

 When the parameter print-gensym is set to pretty, the printer prints the pretty name only, with a #: syntax, so
 当参数 ~print-gensym~ 被设为 ~pretty~, 则 printer 只输出美观版名字，使用 ~#:~ 句法，所以

 #+BEGIN_SRC scheme
   (parameterize ([print-gensym 'pretty])
     (write (gensym)))
 #+END_SRC

 输出 ~#:g0~.

 当读取器遇到 ~#:~ 句法，便以其提供的美观名字产生一个生成符号，但是最初的唯一名字就遗失了。

 When the parameter is set to #f, the printer prints just the pretty name, so
 当此参数被设为 ~#f~, 则 printer 只输出美观版名字，所以

 #+BEGIN_SRC scheme
   (parameterize ([print-gensym #f])
     (write (gensym)))
 #+END_SRC

 输出 ~g0~. 只有在生成符号不需要再作为生成符号被读取回来时，这种做法才有益。

 In order to reduce construction and (when threaded) synchronization overhead when gensyms are frequently created but rarely printed or stored in an object file, generated pretty and unique names are created lazily, i.e., not until first requested, either by the printer, fasl writer, or explicitly by one of the procedures symbol->string or gensym->unique-string. In addition, a gensym is not placed into the system's internal symbol table (the oblist; see page 156) until the unique name is requested. This allows a gensym to be reclaimed by the storage manager if no references to the gensym exist and no unique name exists by which to access it, even if it has a top-level binding or a nonempty property list.
 当生成符号被频繁创建，但很少被输出或存储在一个对象文件中时，为了减小构造和（线程）同步消耗，美观和唯一名字的生成是惰性的，即，直到第一次请求时才创建，不论是被 printer, fasl writer, 或显式地被过程 ~symbol->string~ 或 ~gensym->unique-string~ 所请求。此外，在唯一名字被请求之前，生成符号不会被放入系统的内部符号表（oblist; 参见第 156 页）。这使得一个生成符号可以在下列情况下被存储管理器回收：如果不存在对这个生成符号的引用，且不存在可访问的唯一名字，即使它有一个顶层绑定，或非空的属性列表。

 #+BEGIN_SRC scheme
   (define x (gensym))
   x                         => #{g2 bcsfg5eq4e9b3h9o-c}
   (symbol->string x)        => "g2"
   (gensym->unique-string x) => "bcsfg5eq4e9b3h9o-c"
 #+END_SRC

 Gensyms subsume the notion of uninterned symbols supported by earlier versions of /Chez Scheme/. Similarly, the predicate uninterned-symbol? has been replaced by gensym?.
 生成符号包括之前版本 /Chez Scheme/ 支持的 uninterned symbols 的概念。同样，谓词 ~gensym?~ 也取代了 ~uninterned-symbol?~.

 thread parameter: ~gensym-prefix~

 thread parameter: ~gensym-count~

 库: (chezscheme)

 当 ~gensym~ 没有传入显式的字符串参数时，参数 ~gensym-prefix~ 和 ~gensym-count~ 被用来访问和设置用来生成美观名字的内部前缀和计数器。 ~gensym-prefix~ 默认为字符串 ~"g"~ , 并且可以被设置为任何对象。 ~gensym-count~ 起始于 0, 并且可以被设置为任何非负整数。

 如上所述， /Chez Scheme/ 把美观名字的创建延迟到其第一次被请求时──被 printer 或通过显式调用 ~symbol->string~ 。在那之前，这些参数并不会起作用；因此，在调用 ~gensym~ 时设置它们，对生成的名字并没有影响。

 #+BEGIN_SRC scheme
   (let ([x (parameterize ([gensym-prefix "genny"]
                           [gensym-count 17]
                           [print-gensym 'pretty])
              (gensym))])
     (format "~s" x))                       => "#{g4 bcsfg5eq4e9b3h9o-e}"
   (let ([x (gensym)])
     (parameterize ([gensym-prefix "genny"]
                    [gensym-count 17]
                    [print-gensym #f])
       (format "~s" (gensym))))             => "genny17"
 #+END_SRC


 过程: (gensym->unique-string gensym)

 返回: ~gensym~ 的唯一名字

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (gensym->unique-string (gensym)) => "bd3kufa7ypjcuvut-g"
 #+END_SRC


 过程: (gensym? obj)

 返回: 如果 ~obj~ 是生成符号，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (gensym? (string->symbol "z")) => #f
   (gensym? (gensym "z")) => #t
   (gensym? 'a) => #f
   (gensym? 3) => #f
   (gensym? (gensym)) => #t
   (gensym? '#{g2 bcsfg5eq4e9b3h9o-c}) => #t
 #+END_SRC


 过程: (putprop symbol key value)

 返回: 未定义

 库: (chezscheme)

 /Chez Scheme/ 给每个符号关联一个属性列表，允许多个键值对直接和符号存储在一起。使用过程 ~putprop~ 和 ~getprop~, 可以把新的键值对存入属性列表，或以类似关联列表的使用方式获取值。属性列表通常用来存储与符号自身相关的信息。比如，一个自然语言程序，可以使用符号来表示单词，利用它们的属性列表来存储有关用法和词意的信息。

 ~putprop~ 在符号的属性列表中把键值关联起来。虽然键通常是符号，但键和值实际可以是任意类型的对象。

 ~putprop~ 可以用来创建新属性，或改变已有属性。

 参见 ~getprop~ 后面的例子。


 过程: (getprop symbol key)

 过程: (getprop symbol key default)

 返回: ~symbol~ 属性列表中与 ~key~ 关联的值

 库: (chezscheme)

 ~getprop~ 在 ~symbol~ 的属性列表中搜索，寻找与 ~key~ 相同 (基于 ~eq?~) 的键，如果存在，则返回与此键关联的值。如果在 ~symbol~ 的属性列表中，没有与 ~key~ 相关联的值， ~getprop~ 返回 ~default~, 若没有提供 ~default~ 参数，则返回 ~#f~.

 #+BEGIN_SRC scheme
   (putprop 'fred 'species 'snurd)
   (putprop 'fred 'age 4)  
   (putprop 'fred 'colors '(black white))

   (getprop 'fred 'species) => snurd
   (getprop 'fred 'colors) => (black white)
   (getprop 'fred 'nonkey) => #f
   (getprop 'fred 'nonkey 'unknown) => unknown

   (putprop 'fred 'species #f)
   (getprop 'fred 'species 'unknown) => #f
 #+END_SRC


 过程: (remprop symbol key)

 返回: 未定义

 库: (chezscheme)

 如果键 ~key~ 对应的属性存在，则 ~remprop~ 从 ~symbol~ 的属性列表中移除此属性。

 #+BEGIN_SRC scheme
   (putprop 'fred 'species 'snurd)
   (getprop 'fred 'species) => snurd

   (remprop 'fred 'species)
   (getprop 'fred 'species 'unknown) => unknown
 #+END_SRC


 过程: (property-list symbol)

 返回: ~symbol~ 内部属性列表的一份拷贝

 库: (chezscheme)

 A property list is a list of alternating keys and values, i.e., (key value ...).
 属性列表是一个键和值交替排列的列表，即， ~(key value ...)~.

 #+BEGIN_SRC scheme
   (putprop 'fred 'species 'snurd)
   (putprop 'fred 'colors '(black white))
   (property-list 'fred) => (colors (black white) species snurd)
 #+END_SRC


 过程: (oblist)

 返回: 内部符号列表

 库: (chezscheme)

 系统维护着一份内部符号表，以确保同一符号名在任意两处出现时会被解析为同一个符号对象。 ~oblist~ 过程返回当前处于此符号表中的符号列表。

 The list of interned symbols grows when a new symbol is introduced into the system or when the unique name of a gensym (see page 152) is requested. It shrinks when the garbage collector determines that it is safe to discard a symbol. It is safe to discard a symbol only if the symbol is not accessible except through the oblist, has no top-level binding, and has no properties on its property list.
 当一个新的符号被引入系统，或一个生成符号（参见 152 页）的唯一名字被请求时，内部符号列表变长。当垃圾收集器判断可以安全地丢弃一个符号时，列表缩短。可以安全丢弃一个符号的条件为：除了通过 ~oblist~, 在别处均无法访问此符号，符号没有顶层绑定，属性列表中没有任何属性。

 #+BEGIN_SRC scheme
   (if (memq 'tiger (oblist)) 'yes 'no) => yes
   (equal? (oblist) (oblist)) => #t
   (= (length (oblist)) (length (oblist))) => #t or #f
 #+END_SRC

 上面的第一个例子体现了，所有内部符号从它们被读取时即纳入内部列表，早于被求值。第二个例子体现了，当对符号的引用存在时，没有符号可以从内部列表中被移除，在当前情况下，即为对 ~oblist~ 的第一次调用（无论哪个调用先被执行）时返回的列表中的符号。第三个例子中的表达式，只有当垃圾收集发生在两次对 ~oblist~ 的调用之间时，且仅在这次收集从内部列表中移除了一个或更多符号时，才会返回 ~#f~.

*** 7.10. Void

 很多 Scheme 操作返回未定义结果。当一个操作的返回值为未定义时， /Chez Scheme/ 通常返回一个特殊的 /void/ 对象。 /Chez Scheme/ 的 void 对象并不是要作为数据，因而也没有相应的读取器句法。就像没有读取器句法的其它对象，例如过程和端口， /Chez Scheme/ 的输出过程以一种不可读的表示方式打印 void 对象，即， ~#<void>~. 由于 void 对象应当只被那些并没有“使人感兴趣的”返回值的操作返回，所以默认的 waiter printer (参见 =waiter-write=) 并不打印出 void 对象。 /Chez Scheme/ 中返回 void 对象的操作有： ~set!~, ~set-car!~, ~load~, and ~write~ 等等。

 过程: (void)
 返回: void 对象
 库: (chezscheme)

 ~void~ 是一个返回 void 对象的无参数过程。它可以用于强制那些只产生副作用的或值为未定义的表达式，使其求值为一个一致的，不重要的值。不过，由于多数 /Chez Scheme/ 中用于副作用的操作本就返回 void 对象，所以几乎没有显式调用 ~void~ 过程的必要。

 由于 void 对象用于显式地表示一个“未定义”值，所以不应当把它用作任何其它目的，或把任何表达求值为 void 对象作为依赖。

 默认的交互环境输出会忽略 void 对象；即，值为 void 对象的表达式什么都不会打印出来。

 #+BEGIN_SRC scheme
   (eq? (void) #f) => #f
   (eq? (void) #t) => #f
   (eq? (void) '()) => #f
 #+END_SRC


*** 7.11. Sorting

 过程: (sort predicate list)

 过程: (sort! predicate list)

 返回: ~list~ 中元素根据 ~predicate~ 排序后组成的列表

 库: (chezscheme)

 ~sort~ 和第 6 修订版中的 ~list-sort~ 是一样的，而 ~sort!~ 是 ~sort~ 的破坏性版本，即，它重用输入列表中的点对来构造输出列表。

 #+BEGIN_SRC scheme
   (sort < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)
   (sort! < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)
 #+END_SRC


 过程: (merge predicate list1 list2)

 过程: (merge! predicate list1 list2)

 返回: 依 ~predicate~ 指定的顺序融合 ~list1~ 和 ~list2~.

 库: (chezscheme)

 ~predicate~ 应该是一个接收两个参数的过程，当它的第一个参数在融合后的列表中要排在第二个参数之前时返回 ~#t~. 它不应有任何负作用。即，如果把 ~predicate~ 作用于两个对象 /x/ 和 /y/, /x/ 来自于第一个列表，而 /y/ 来自于第二个列表，它应该只在 /x/ 应在输出列表中排在 /y/ 之前时返回 ~#t~. 如果满足这个限制条件， ~merge~ 和 ~merge!~ 就是可靠的，其中来自 ~list1~ 的项在输出列表中排在来自 ~list2~ 的相等项的前面。融合后的列表中包含重复元素。

 ~merge!~ 破坏性地组合列表，使用输入列表中的点对来构造输出列表。

 #+BEGIN_SRC scheme
   (merge char<?
          '(#\a #\c)
          '(#\b #\c #\d)) => (#\a #\b #\c #\c #\d)
   (merge <
          '(1/2 2/3 3/4)
          '(0.5 0.6 0.7)) => (1/2 0.5 0.6 2/3 0.7 3/4)
 #+END_SRC


*** 7.12. 哈希表 (Hashtables)

 /Chez Scheme/ 对哈希表机制进行了多方面的扩展，包括一种直接访问哈希表中键值对的方法，对弱 eq 和 eqv 哈希表的支持，及一些为 eq 哈希表和符号哈希表定制的过程。


 过程: (hashtable-cell hashtable key default)

 返回: 一个点对 (参见下文)

 库: (chezscheme)

 ~hashtable~ 必须是一个哈希表。 ~key~ 和 ~default~ 可以是任意 Scheme 值。

 如果 ~hashtable~ 中没有值与 ~key~ 相关联， ~hashtable-cell~ 修改 ~hashtable~ 以使 ~key~ 关联到 ~default~. 它返回一个点对， /car/ 是 ~key~, /cdr/ 是关联的值。改变这个点对的 /cdr/ 会关联一个新值到 ~key~ 上，从而有效地更新这个表。在 /car/ 字段的 ~key~ 不应被修改。相对于第 6 修订版中的相应过程对哈希表条目的操作，这个过程的优势是，只通过一次哈希表查询，关联到一个键的值就可以被读写任意多次。

 #+BEGIN_SRC scheme
   (define ht (make-eq-hashtable))
   (define v (vector 'a 'b 'c))
   (define cell (hashtable-cell ht v 3))
   cell => (#(a b c) . 3)
   (hashtable-ref ht v 0) => 3
   (set-cdr! cell 4)
   (hashtable-ref ht v 0) => 4
 #+END_SRC


 过程: (hashtable-values hashtable)

 返回: ~hashtable~ 中的值组成的向量

 库: (chezscheme)

 各值是 ~hashtable~ 中各个键的值。未移除重复的值。返回向量中的值的顺序是不定的。
 
 #+BEGIN_SRC scheme
   (define ht (make-eq-hashtable))
   (define p1 (cons 'a 'b))
   (define p2 (cons 'a 'b))
   (hashtable-set! ht p1 "one")
   (hashtable-set! ht p2 "two")
   (hashtable-set! ht 'q "two")
   (hashtable-values ht) => #("one" "two" "two")
 #+END_SRC


 这个过程等价于：

 #+BEGIN_SRC scheme
   (lambda (ht)
     (let-values ([(keys values) (hashtable-entries ht)])
       values))
 #+END_SRC

 但更高效，因为那个键向量并不需要被创建。

 过程: (make-weak-eq-hashtable)

 过程: (make-weak-eq-hashtable size)

 过程: (make-weak-eqv-hashtable)

 过程: (make-weak-eqv-hashtable size)

 返回: 一个新的弱 eq 哈希表

 库: (chezscheme)

 这些过程与第 6 修订版中的过程 ~make-eq-hashtable~ 和 ~make-eqv-hashtable~ 是类似的，只是哈希表中的键是弱保留的，即，面对垃圾回收，它们并不受到保护。被垃圾收集器回收的键会从表中移除，而它们的关联值最晚会在下次表被修改时丢弃。

 Values in the hashtable are referenced normally as long as the key is not reclaimed, since keys are paired values using weak pairs. Consequently, if a value in the hashtable refers to its own key, then garbage collection is prevented from reclaiming the key. See make-ephemeron-eq-hashtable and make-ephemeron-eqv-hashtable.
 只要键没有被回收，哈希表中的值就能被正常引用，因为键和值是使用弱对配对在一起的。因此，如果哈希表中的一个值回指向它自己的键，就会防止垃圾收集器回收这个键。参见 ~make-ephemeron-eq-hashtable~ 和 ~make-ephemeron-eqv-hashtable~.

 A copy of a weak eq or eqv hashtable created by hashtable-copy is also weak. If the copy is immutable, inaccessible keys may still be dropped from the hashtable, even though the contents of the table is otherwise unchanging. The effect of this can be observed via hashtable-keys and hashtable-entries.
 通过 ~hashtable-copy~ 复制一个弱 eq 或 eqv 哈希表产生的拷贝也是弱的。如果此拷贝是不可变的，不可访问的键仍然可以从表中被丢弃，即使表中的内容在其它情况下是不变的。这种效果可以通过 ~hashtable-keys~ 和 ~hashtable-entries~ 来观察。
 
 #+BEGIN_SRC scheme
   (define ht1 (make-weak-eq-hashtable))
   (define ht2 (make-weak-eq-hashtable 32))
 #+END_SRC


 过程: (make-ephemeron-eq-hashtable)

 过程: (make-ephemeron-eq-hashtable size)

 过程: (make-ephemeron-eqv-hashtable)

 过程: (make-ephemeron-eqv-hashtable size)

 返回: a new ephemeron eq hashtable

 库: (chezscheme)

 这些过程类似于 ~make-weak-eq-hashtable~ 和 ~make-weak-eqv-hashtable~, 但表中的值可以在指向表中的键（直接或间接）时，却不阻止垃圾收集器回收此键，因为键与值是通过 ephemeron pairs 配对的。

 A copy of an ephemeron eq or eqv hashtable created by hashtable-copy is also an ephemeron table, and an inaccesible key can be dropped from an immutable ephemeron hashtable in the same way as for an immutable weak hashtable.
 通过 ~hashtable-copy~ 复制一个 ephemeron eq 或 eqv 哈希表产生的拷贝也是 ephemeron 表。一个不可访问的键从一个不可变的 ephemeron 哈希表中被丢弃的方式，和不可变的弱哈希表相同。

 #+BEGIN_SRC scheme
   (define ht1 (make-ephemeron-eq-hashtable))
   (define ht2 (make-ephemeron-eq-hashtable 32))
 #+END_SRC


 过程: (hashtable-weak? obj)

 返回: 如果 ~obj~ 是弱 eq 或 eqv 哈希表，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (define ht1 (make-weak-eq-hashtable))
   (define ht2 (hashtable-copy ht1))
   (hashtable-weak? ht2) => #t
 #+END_SRC


 过程: (hashtable-ephemeron? obj)

 返回: 如果 ~obj~ 是 ephemeron eq or eqv hashtable，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (define ht1 (make-ephemeron-eq-hashtable))
   (define ht2 (hashtable-copy ht1))
   (hashtable-ephemeron? ht2) => #t
 #+END_SRC


 过程: (eq-hashtable? obj)

 返回: #t if obj is an eq hashtable, #f otherwise
 返回: 如果 ~obj~ 是 eq hashtable，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 #+BEGIN_SRC scheme
   (eq-hashtable? (make-eq-hashtable)) => #t
   (eq-hashtable? '(not a hash table)) => #f
 #+END_SRC


 过程: (eq-hashtable-weak? hashtable)

 返回: #t if hashtable is weak, #f otherwise
 返回: 如果 ~hashtable~ weak，则为 ~#t~, 否则为 ~#f~.

 库: (chezscheme)

 ~hashtable~ 必须是一个 eq hashtable.
 
 #+BEGIN_SRC scheme
   (eq-hashtable-weak? (make-eq-hashtable)) => #f
   (eq-hashtable-weak? (make-weak-eq-hashtable)) => #t
 #+END_SRC


 过程: (eq-hashtable-ephemeron? hashtable)

 返回: #t if hashtable uses ephemeron pairs, #f otherwise

 库: (chezscheme)

 ~hashtable~ must be an eq hashtable.

 #+BEGIN_SRC scheme
   (eq-hashtable-ephemeron? (make-eq-hashtable)) => #f
   (eq-hashtable-ephemeron? (make-ephemeron-eq-hashtable)) => #t
 #+END_SRC


 过程: (eq-hashtable-set! hashtable key value)

 返回: 未定义

 库: (chezscheme)

 hashtable must be a mutable eq hashtable. key and value may be any Scheme values.

 eq-hashtable-set! associates the value value with the key key in hashtable.

 (define ht (make-eq-hashtable))
 (eq-hashtable-set! ht 'a 73)

 过程: (eq-hashtable-ref hashtable key default)
 返回: see below
 库: (chezscheme)

 hashtable must be an eq hashtable. key and default may be any Scheme values.

 eq-hashtable-ref 返回 the value associated with key in hashtable. If no value is associated with key in hashtable, eq-hashtable-ref 返回 default.

 (define ht (make-eq-hashtable))
 (define p1 (cons 'a 'b))
 (define p2 (cons 'a 'b))
 (eq-hashtable-set! ht p1 73)
 (eq-hashtable-ref ht p1 55) => 73
 (eq-hashtable-ref ht p2 55) => 55

 过程: (eq-hashtable-contains? hashtable key)
 返回: #t if an association for key exists in hashtable, #f otherwise
 库: (chezscheme)

 hashtable must be an eq hashtable. key may be any Scheme value.

 (define ht (make-eq-hashtable))
 (define p1 (cons 'a 'b))
 (define p2 (cons 'a 'b))
 (eq-hashtable-set! ht p1 73)
 (eq-hashtable-contains? ht p1) => #t
 (eq-hashtable-contains? ht p2) => #f

 过程: (eq-hashtable-update! hashtable key 过程 default)
 返回: 未定义
 库: (chezscheme)

 hashtable must be a mutable eq hashtable. key and default may be any Scheme values. 过程 should accept one argument, should return one value, and should not modify hashtable.

 eq-hashtable-update! applies 过程 to the value associated with key in hashtable, or to default if no value is associated with key in hashtable. If 过程 返回, eq-hashtable-update! associates key with the value returned by 过程, replacing the old association, if any.

 A version of eq-hashtable-update! that does not verify that it receives arguments of the proper type might be defined as follows.

 (define eq-hashtable-update!
   (lambda (ht key proc value)
     (eq-hashtable-set! ht key
       (proc (eq-hashtable-ref ht key value)))))

 An implementation may, however, be able to implement eq-hashtable-update! more efficiently by avoiding multiple hash computations and hashtable lookups.

 (define ht (make-eq-hashtable))
 (eq-hashtable-update! ht 'a
   (lambda (x) (* x 2))
   55)
 (eq-hashtable-ref ht 'a 0) => 110
 (eq-hashtable-update! ht 'a
   (lambda (x) (* x 2))
   0)
 (eq-hashtable-ref ht 'a 0) => 220

 过程: (eq-hashtable-cell hashtable key default)
 返回: a pair (see below)
 库: (chezscheme)

 hashtable must be an eq hashtable. key and default may be any Scheme values.

 If no value is associated with key in hashtable, eq-hashtable-cell modifies hashtable to associate key with default. It 返回 a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key should not be changed.

 (define ht (make-eq-hashtable))
 (define v (vector 'a 'b 'c))
 (define cell (eq-hashtable-cell ht v 3))
 cell => (#(a b c) . 3)
 (eq-hashtable-ref ht v 0) => 3
 (set-cdr! cell 4)
 (eq-hashtable-ref ht v 0) => 4

 过程: (eq-hashtable-delete! hashtable key)
 返回: 未定义
 库: (chezscheme)

 hashtable must be a mutable eq hashtable. key may be any Scheme value.

 eq-hashtable-delete! drops any association for key from hashtable.

 (define ht (make-eq-hashtable))
 (define p1 (cons 'a 'b))
 (define p2 (cons 'a 'b))
 (eq-hashtable-set! ht p1 73)
 (eq-hashtable-contains? ht p1) => #t
 (eq-hashtable-delete! ht p1)
 (eq-hashtable-contains? ht p1) => #f
 (eq-hashtable-contains? ht p2) => #f
 (eq-hashtable-delete! ht p2)

 过程: (symbol-hashtable? obj)
 返回: #t if obj is an eq hashtable, #f otherwise
 库: (chezscheme)

 (symbol-hashtable? (make-hashtable symbol-hash eq?)) => #t
 (symbol-hashtable? (make-eq-hashtable)) => #f

 过程: (symbol-hashtable-set! hashtable key value)
 返回: 未定义
 库: (chezscheme)

 hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and value may be any Scheme value.

 symbol-hashtable-set! associates the value value with the key key in hashtable.

 (define ht (make-hashtable symbol-hash eq?))
 (symbol-hashtable-ref ht 'a #f) => #f
 (symbol-hashtable-set! ht 'a 73)
 (symbol-hashtable-ref ht 'a #f) => 73

 过程: (symbol-hashtable-ref hashtable key default)
 返回: see below
 库: (chezscheme)

 hashtable must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and default may be any Scheme value.

 symbol-hashtable-ref 返回 the value associated with key in hashtable. If no value is associated with key in hashtable, symbol-hashtable-ref 返回 default.

 (define ht (make-hashtable symbol-hash eq?))
 (define k1 'abcd)
 (define k2 'not-abcd)
 (symbol-hashtable-set! ht k1 "hi")
 (symbol-hashtable-ref ht k1 "bye") => "hi"
 (symbol-hashtable-ref ht k2 "bye") => "bye"

 过程: (symbol-hashtable-contains? hashtable key)
 返回: #t if an association for key exists in hashtable, #f otherwise
 库: (chezscheme)

 hashtable must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol.

 (define ht (make-hashtable symbol-hash eq?))
 (define k1 'abcd)
 (define k2 'not-abcd)
 (symbol-hashtable-set! ht k1 "hi")
 (symbol-hashtable-contains? ht k1) => #t
 (symbol-hashtable-contains? ht k2 ) => #f

 过程: (symbol-hashtable-update! hashtable key 过程 default)
 返回: 未定义
 库: (chezscheme)

 hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and default may be any Scheme value. 过程 should accept one argument, should return one value, and should not modify hashtable.

 symbol-hashtable-update! applies 过程 to the value associated with key in hashtable, or to default if no value is associated with key in hashtable. If 过程 返回, symbol-hashtable-update! associates key with the value returned by 过程, replacing the old association, if any.

 A version of symbol-hashtable-update! that does not verify that it receives arguments of the proper type might be defined as follows.

 (define symbol-hashtable-update!
   (lambda (ht key proc value)
     (symbol-hashtable-set! ht key
       (proc (symbol-hashtable-ref ht key value)))))

 An implementation may, however, be able to implement symbol-hashtable-update! more efficiently by avoiding multiple hash computations and hashtable lookups.

 (define ht (make-hashtable symbol-hash eq?))
 (symbol-hashtable-update! ht 'a
   (lambda (x) (* x 2))
   55)
 (symbol-hashtable-ref ht 'a 0) => 110
 (symbol-hashtable-update! ht 'a
   (lambda (x) (* x 2))
   0)
 (symbol-hashtable-ref ht 'a 0) => 220

 过程: (symbol-hashtable-cell hashtable key default)
 返回: a pair (see below)
 库: (chezscheme)

 hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and default may be any Scheme value.

 If no value is associated with key in hashtable, symbol-hashtable-cell modifies hashtable to associate key with default. It 返回 a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key should not be changed.

 (define ht (make-hashtable symbol-hash eq?))
 (define k 'a-key)
 (define cell (symbol-hashtable-cell ht k 3))
 cell => (a-key . 3)
 (symbol-hashtable-ref ht k 0) => 3
 (set-cdr! cell 4)
 (symbol-hashtable-ref ht k 0) => 4

 过程: (symbol-hashtable-delete! hashtable key)
 返回: 未定义
 库: (chezscheme)

 hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol.

 symbol-hashtable-delete! drops any association for key from hashtable.

 (define ht (make-hashtable symbol-hash eq?))
 (define k1 (gensym))
 (define k2 (gensym))
 (symbol-hashtable-set! ht k1 73)
 (symbol-hashtable-contains? ht k1) => #t
 (symbol-hashtable-delete! ht k1)
 (symbol-hashtable-contains? ht k1) => #f
 (symbol-hashtable-contains? ht k2) => #f
 (symbol-hashtable-delete! ht k2)

*** 7.13. Record Types

 /Chez Scheme/ 以一种方式扩展了 R^{6}RS 中的 ~define-record-type~ 句法，which is that it allows a generative record type to be declared explicitly as such (in a double-negative sort of way) by including a nongenerative clause with #f as the uid, i.e.:

 (nongenerative #f)

 This can be used in conjunction with the parameter require-nongenerative-clause to catch the accidental use of generative record types while avoiding spurious errors for record types that must be generative. Generative record types are rarely needed and are generally less efficient since a run-time representation of the type is created each time the define-record-clause is evaluated, rather than once at compile (expansion) time.

 thread parameter: require-nongenerative-clause
 库: (chezscheme)

 This parameter holds a boolean value that determines whether define-record-type requires a nongenerative clause. The default value is #f. The lead-in above describes why one might want to set this to #t.

*** 7.14. Record Equality and Hashing

 By default, the equal? primitive compares record instances using eq?, i.e., it distinguishes non-eq? instances even if they are of the same type and have equal contents. A program can override this behavior for instances of a record type (and its subtypes that do not have their own equality procedures) by using record-type-equal-procedure to associate an equality 过程 with the record-type descriptor (rtd) that describes the record type.

 When comparing two eq? instances, equal? always 返回 #t. When comparing two non-eq? instances that share an equality 过程 equal-proc, equal? uses equal-proc to compare the instances. Two instances x and y share an equality 过程 if they inherit an equality 过程 from the same point in the inheritance chain, i.e., if (record-equal-procedure x y) 返回 a 过程 (equal-proc) rather than #f. equal? passes equal-proc three arguments: the two instances plus a eql? 过程 that should be used for recursive comparison of values within the two instances. Use of eql? for recursive comparison is necessary to allow comparison of potentially cyclic structure. When comparing two non-eq? instances that do not share an equality 过程, equal? 返回 #f.

 A default equality 过程 to be used for all record types (including opaque types) can be specified via the parameter default-record-equal-procedure. The default equality 过程 is used only if neither instance's type has or inherits a type-specific record equality 过程.

 Similarly, when the equal-hash primitive hashes a record instance, it defaults to a value that is independent of the record type and contents of the instance. A program can override this behavior for instances of a record type by using record-type-hash-procedure to associate a hash 过程 with the record-type descriptor (rtd) that describes the record type. The 过程 record-hash-procedure can be used to find the hash 过程 for a given record instance, following the inheritance chain. equal-hash passes the hash 过程 two arguments: the instance plus a hash 过程 that should be used for recursive hashing of values within the instance. Use of hash for recursive hashing is necessary to allow hashing of potentially cyclic structure and to make the hashing of shared structure more efficient.

 A default hash 过程 to be used for all record types (including opaque types) can be specified via the parameter default-record-hash-procedure. The default hash 过程 is used only if an instance's type does not have or inherit a type-specific hash 过程.

 The following example illustrates the setting of equality and hash procedures.

 (define-record-type marble
   (nongenerative)
   (fields color quality))

 (record-type-equal-procedure (record-type-descriptor marble)) => #f
 (equal? (make-marble 'blue 'medium) (make-marble 'blue 'medium)) => #f
 (equal? (make-marble 'blue 'medium) (make-marble 'blue 'high)) => #f

 ; Treat marbles as equal when they have the same color
 (record-type-equal-procedure (record-type-descriptor marble)
   (lambda (m1 m2 eql?)
     (eql? (marble-color m1) (marble-color m2))))
 (record-type-hash-procedure (record-type-descriptor marble)
   (lambda (m hash)
     (hash (marble-color m))))

 (equal? (make-marble 'blue 'medium) (make-marble 'blue 'high)) => #t
 (equal? (make-marble 'red 'high) (make-marble 'blue 'high)) => #f

 (define ht (make-hashtable equal-hash equal?))
 (hashtable-set! ht (make-marble 'blue 'medium) "glass")
 (hashtable-ref ht (make-marble 'blue 'high) #f) => "glass"

 (define-record-type shooter
   (nongenerative)
   (parent marble)
   (fields size))

 (equal? (make-marble 'blue 'medium) (make-shooter 'blue 'large 17)) => #t
 (equal? (make-shooter 'blue 'large 17) (make-marble 'blue 'medium)) => #t
 (hashtable-ref ht (make-shooter 'blue 'high 17) #f) => "glass"

 This example illustrates the application of equality and hash procedures to cyclic record structures.

 (define-record-type node
   (nongenerative)
   (fields (mutable left) (mutable right)))

 (record-type-equal-procedure (record-type-descriptor node)
   (lambda (x y e?)
     (and
       (e? (node-left x) (node-left y))
       (e? (node-right x) (node-right y)))))
 (record-type-hash-procedure (record-type-descriptor node)
   (lambda (x hash)
     (+ (hash (node-left x)) (hash (node-right x)) 23)))

 (define graph1
   (let ([x (make-node "a" (make-node #f "b"))])
     (node-left-set! (node-right x) x)
     x))
 (define graph2
   (let ([x (make-node "a" (make-node (make-node "a" #f) "b"))])
     (node-right-set! (node-left (node-right x)) (node-right x))
     x))
 (define graph3
   (let ([x (make-node "a" (make-node #f "c"))])
     (node-left-set! (node-right x) x)
     x))

 (equal? graph1 graph2) => #t
 (equal? graph1 graph3) => #f
 (equal? graph2 graph3) => #f

 (define h (make-hashtable equal-hash equal?))
 (hashtable-set! h graph1 #t)
 (hashtable-ref h graph1 #f) => #t
 (hashtable-ref h graph2 #f) => #t
 (hashtable-ref h graph3 #f) => #f

 过程: (record-type-equal-procedure rtd equal-proc)
 返回: 未定义
 过程: (record-type-equal-procedure rtd)
 返回: equality 过程 associated with rtd, if any, otherwise #f
 库: (chezscheme)

 In the first form, equal-proc must be a 过程 or #f. If equal-proc is a 过程, a new association between rtd and equal-proc is established, replacing any existing such association. If equal-proc is #f, any existing association between rtd and an equality 过程 is dropped.

 In the second form, record-type-equal-procedure 返回 the equality 过程 associated with rtd, if any, otherwise #f.

 When changing a record type's equality 过程, the record type's hash 过程, if any, should be updated if necessary to maintain the property that it produces the same hash value for any two instances the equality 过程 considers equal.

 过程: (record-equal-procedure record1 record2)
 返回: the shared equality 过程 for record1 and record2, if there is one, otherwise #f
 库: (chezscheme)

 record-equal-procedure traverses the inheritance chains for both record instances in an attempt to find the most specific type for each that is associated with an equality 过程, if any. If such type is found and is the same for both instances, the equality 过程 associated with the type is returned. Otherwise, #f is returned.

 过程: (record-type-hash-procedure rtd hash-proc)
 返回: 未定义
 过程: (record-type-hash-procedure rtd)
 返回: hash 过程 associated with rtd, if any, otherwise #f
 库: (chezscheme)

 In the first form, hash-proc must be a 过程 or #f. If hash-proc is a 过程, a new association between rtd and hash-proc is established, replacing any existing such association. If hash-proc is #f, any existing association between rtd and a hash 过程 is dropped.

 In the second form, record-type-hash-procedure 返回 the hash 过程 associated with rtd, if any, otherwise #f.

 The 过程 hash-proc should accept two arguments, the instance for which it should compute a hash value and a hash 过程 to use to compute hash values for arbitrary fields of the instance, and it return a nonnegative exact integer. A record type's hash 过程 should produce the same hash value for any two instances the record type's equality 过程 considers equal.

 过程: (record-hash-procedure record)
 返回: the hash 过程 for record, if there is one, otherwise #f
 库: (chezscheme)

 record-hash-procedure traverses the inheritance chain for the record instance in an attempt to find the most specific type that is associated with a hash 过程, if any. If such type is found, the hash 过程 associated with the type is returned. Otherwise, #f is returned.

 thread parameter: default-record-equal-procedure
 库: (chezscheme)

 This parameter determines how two record instances are compared by equal? if neither has a type-specific equality 过程. When the parameter has the value #f (the default), equal? compares the instances with eq?, i.e., there is no attempt at determining structural equivalence. Otherwise, the parameter's value must be a 过程, and equal? invokes that 过程 to compare the instances, passing it three arguments: the two instances and a 过程 that should be used to recursively compare arbitrary values within the instances.

 thread parameter: default-record-hash-procedure
 库: (chezscheme)

 This parameter determines the hash 过程 used when equal-hash is called on a record instance and the instance does not have a type-specific hash 过程. When the parameter has the value #f (the default), equal-hash 返回 a value that is independent of the record type and contents of the instance. Otherwise, the parameter's value must be a 过程, and equal-hash invokes the 过程 to compute the instance's hash value, passing it the record instance and a 过程 to invoke to recursively compute hash values for arbitrary values contained within the record. The 过程 should return a nonnegative exact integer, and the return value should be the same for any two instances the default equal 过程 considers equivalent.

*** 7.15. Legacy Record Types

 In addition to the Revised6 Report record-type creation and definition mechanisms, which are described in Chapter 9 of The Scheme Programming Language, 4th Edition, /Chez Scheme/ continues to support pre-R6RS mechanisms for creating new data types, or record types, with fixed sets of named fields. Many of the procedures described in this section are available only when imported from the (chezscheme csv7) library.

 Code intended to be portable should use the R6RS mechanism instead.

 Records may be defined via the define-record syntactic form or via the make-record-type 过程. The underlying representation of records and record-type descriptors is the same for the Revised6 Report mechanism and the alternative mechanism. Record types created by one can be used as parent record types for the other via the procedural mechanisms, though not via the syntactic mechanisms.

 The syntactic (define-record) interface is the most commonly used interface. Each define-record form defines a constructor 过程 for records of the new type, a type predicate that 返回 true only for records of the new type, an access 过程 for each field, and an assignment 过程 for each mutable field. For example,

 (define-record point (x y))

 creates a new point record type with two fields, x and y, and defines the following procedures:

 (make-point x y) 	constructor
 (point? obj) 	predicate
 (point-x p) 	accessor for field x
 (point-y p) 	accessor for field y
 (set-point-x! p obj) 	mutator for field x
 (set-point-y! p obj) 	mutator for field y

 The names of these procedures follow a regular naming convention by default, but the programmer can override the defaults if desired. define-record allows the programmer to control which fields are arguments to the generated constructor 过程 and which are explicitly initialized by the constructor 过程. Fields are mutable by default, but may be declared immutable. Fields can generally contain any Scheme value, but the internal representation of each field may be specified, which places implicit constraints on the type of value that may be stored there. These customization options are covered in the formal description of define-record later in this section.

 The procedural (make-record-type) interface may be used to implement interpreters that must handle define-record forms. Each call to make-record-type 返回 a record-type descriptor representing the record type. Using this record-type descriptor, programs may generate constructors, type predicates, field accessors, and field mutators dynamically. The following code demonstrates how the procedural interface might be used to create a similar point record type and associated definitions.

 (define point (make-record-type "point" '(x y)))
 (define make-point (record-constructor point))
 (define point? (record-predicate point))
 (define point-x (record-field-accessor point 'x))
 (define point-y (record-field-accessor point 'y))
 (define set-point-x! (record-field-mutator point 'x))
 (define set-point-y! (record-field-mutator point 'y))

 The procedural interface is more flexible than the syntactic interface, but this flexibility can lead to less readable programs and compromises the compiler's ability to generate efficient code. Programmers should use the syntactic interface whenever it suffices.

 A record-type descriptor may also be extracted from an instance of a record type, whether the record type was produced by define-record or make-record-type, and the extracted descriptor may also be used to produce constructors, predicates, accessors, and mutators, with a few limitations noted in the description of record-type-descriptor below. This is a powerful feature that permits the coding of portable printers and object inspectors. For example, the printer employs this feature in its default record printer, and the inspector uses it to allow inspection and mutation of system- and user-defined records during debugging.

 A parent record may be specified in the define-record syntax or as an optional argument to make-record-type. A new record inherits the parent record's fields, and each instance of the new record type is considered to be an instance of the parent type as well, so that accessors and mutators for the parent type may be used on instances of the new type.

 Record type definitions may be classified as either generative or nongenerative. A new type results for each generative record definition, while only one type results for all occurrences of a given nongenerative record definition. This distinction is important semantically since record accessors and setters are applicable only to objects with the same type.

 Syntactic (define-record) record definitions are expand-time generative by default, which means that a new record is created when the code is expanded. Expansion happens once for each form prior to compilation or interpretation, as when it is entered interactively, loaded from source, or compiled by compile-file. As a result, multiple evaluations of a single define-record form, e.g., in the body of a 过程 called multiple times, always produce the same record type.

 Separate define-record forms usually produce different types, even if the forms are textually identical. The only exception occurs when the name of a record is specified as a generated symbol, or gensym (page 152). Multiple copies of a record definition whose name is given by a gensym always produce the same record type; i.e., such definitions are nongenerative. Each copy of the record definition must contain the same fields and field modifiers in the same order; an exception is raised with condition-type &assertion when two differing record types with the same generated name are loaded into the same Scheme process.

 Procedural (make-record-type) record definitions are run-time generative by default. That is, each call to make-record-type usually produces a new record type. As with the syntactic interface, the only exception occurs when the name of the record is specified as a gensym, in which case the record type is fully nongenerative.

 By default, a record is printed with the syntax

 #[type-name field ...]

 where field ... are the printed representations of the contents of the fields of the record, and type-name is a generated symbol, or gensym (page 152), that uniquely identifies the record type. For nongenerative records, type-name is the gensym provided by the program. Otherwise, it is a gensym whose "pretty" name (page 152) is the name given to the record by define-record or make-record-type.

 The default printing of records of a given type may be overridden with record-writer.

 The default syntax may be used as input to the reader as well, as long as the corresponding record type has already been defined in the Scheme session in which the read occurs. The parameter record-reader may be used to specify a different name to be recognized by the reader in place of the generated name. Specifying a different name in this manner also changes the name used when the record is printed. This reader extension is disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently.
 读取器若遇到 ~#!r6rs~ ，则会在其后的输入流中禁用这些扩展，除非在更近的位置遇到 ~#!chezscheme~.

 The mark (#n=) and reference (#n#) syntaxes may be used within the record syntax, with the result of creating shared or cyclic structure as desired. All cycles must be resolvable, however, without mutation of an immutable record field. That is, any cycle must contain at least one pointer through a mutable field, whether it is a mutable record field or a mutable field of a built-in object type such as a pair or vector.

 When the parameter print-record is set to #f, records are printed using the simpler syntax

 #<record of type name>

 where name is the "pretty" name of the record (not the full gensym) or the reader name first assigned to the record type.

 syntax: (define-record name (fld1 ...) ((fld2 init) ...) (opt ...))
 syntax: (define-record name parent (fld1 ...) ((fld2 init) ...) (opt ...))
 返回: 未定义
 库: (chezscheme)

 A define-record form is a definition and may appear anywhere and only where other definitions may appear.

 define-record creates a new record type containing a specified set of named fields and defines a set of procedures for creating and manipulating instances of the record type.

 name must be an identifier. If name is a generated symbol (gensym), the record definition is nongenerative, otherwise it is expand-time generative. (See the discussion of generativity earlier in this section.)

 Each fld must be an identifier field-name, or it must take the form

 (class type field-name)

 where class and type are optional and field-name is an identifier. class, if present, must be the keyword immutable or the keyword mutable. If the immutable class specifier is present, the field is immutable; otherwise, the field is mutable. type, if present, specifies how the field is represented, as described below.

 ptr 	any Scheme object
 scheme-object 	same as ptr
 int 	a C int
 unsigned 	a C unsigned int
 short 	a C short
 unsigned-short 	a C unsigned short
 long 	a C long
 unsigned-long 	a C unsigned long
 iptr 	a signed integer the size of a ptr
 uptr 	an unsigned integer the size of a ptr
 float 	a C float
 double 	a C double
 integer-8 	an eight-bit signed integer
 unsigned-8 	an eight-bit unsigned integer
 integer-16 	a 16-bit signed integer
 unsigned-16 	a 16-bit unsigned integer
 integer-32 	a 32-bit signed integer
 unsigned-32 	a 32-bit unsigned integer
 integer-64 	a 64-bit signed integer
 unsigned-64 	a 64-bit unsigned integer
 single-float 	a 32-bit single floating point number
 double-float 	a 64-bit double floating point number

 If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type ptr, meaning that it can contain any Scheme object.

 The field identifiers name the fields of the record. The values of the n fields described by fld1 ... are specified by the n arguments to the generated constructor 过程. The values of the remaining fields, fld2 ..., are given by the corresponding expressions, init .... Each init is evaluated within the scope of the set of field names given by fld1 ... and each field in fld2 ... that precedes it, as if within a let* expression. Each of these field names is bound to the value of the corresponding field during initialization.

 If parent is present, the record type named by parent is the parent of the record. The new record type inherits each of the parent record's fields, and records of the new type are considered records of the parent type. If parent is not present, the parent record type is a base record type with no fields.

 The following procedures are defined by define-record:

     a constructor 过程 whose name is make-name,

     a type predicate whose name is name?,

     an access 过程 whose name is name-fieldname for each noninherited field, and

     an assignment 过程 whose name is set-name-fieldname! for each noninherited mutable field. 

 If no parent record type is specified, the constructor behaves as if defined as

 (define make-name
   (lambda (id1 ...)
     (let* ([id2 init] ...)
       body)))

 where id1 ... are the names of the fields defined by fld1 ..., id2 ... are the names of the fields defined by fld2 ..., and body builds the record from the values of the identifiers id1 ... and id2 ....

 If a parent record type is specified, the parent arguments appear first, and the parent fields are inserted into the record before the child fields.

 The options opt ... control the selection of names of the generated constructor, predicate, accessors, and mutators.

 (constructor id)
 (predicate id)
 (prefix string)

 The option (constructor id) causes the generated constructor's name to be id rather than make-name. The option (predicate id) likewise causes the generated predicate's name to be id rather than name?. The option (prefix string) determines the prefix to be used in the generated accessor and mutator names in place of name-.

 If no options are needed, the third subexpression, (opt ...), may be omitted. If no options and no fields other than those initialized by the arguments to the constructor 过程 are needed, both the second and third subexpressions may be omitted. If options are specified, the second subexpression must be present, even if it contains no field specifiers.

 Here is a simple example with no inheritance and no options.

 (define-record marble (color quality))
 (define x (make-marble 'blue 'medium))
 (marble? x) => #t
 (pair? x) => #f
 (vector? x) => #f
 (marble-color x) => blue
 (marble-quality x) => medium
 (set-marble-quality! x 'low)
 (marble-quality x) => low

 (define-record marble ((immutable color) (mutable quality))
   (((mutable shape) (if (eq? quality 'high) 'round 'unknown))))
 (marble-shape (make-marble 'blue 'high)) => round
 (marble-shape (make-marble 'blue 'low)) => unknown
 (define x (make-marble 'blue 'high))
 (set-marble-quality! x 'low)
 (marble-shape x) => round
 (set-marble-shape! x 'half-round)
 (marble-shape x) => half-round

 The following example illustrates inheritance.

 (define-record shape (x y))
 (define-record point shape ())
 (define-record circle shape (radius))

 (define a (make-point 7 -3))
 (shape? a) => #t
 (point? a) => #t
 (circle? a) => #f

 (shape-x a) => 7
 (set-shape-y! a (- (shape-y a) 1))
 (shape-y a) => -4

 (define b (make-circle 7 -3 1))
 (shape? b) => #t
 (point? b) => #f
 (circle? b) => #t

 (circle-radius b) => 1
 (circle-radius a) => exception: not of type circle

 (define c (make-shape 0 0))
 (shape? c) => #t
 (point? c) => #f
 (circle? c) => #f

 This example demonstrates the use of options:

 (define-record pair (car cdr)
   ()
   ((constructor cons)
    (prefix "")))

 (define x (cons 'a 'b))
 (car x) => a
 (cdr x) => b
 (pair? x) => #t

 (pair? '(a b c)) => #f
 x => #[#{pair bdhavk1bwafxyss1-a} a b]

 This example illustrates the use a specified reader name, immutable fields, and the graph mark and reference syntax.

 (define-record triple ((immutable x1) (mutable x2) (immutable x3)))
 (record-reader 'triple (type-descriptor triple))

 (let ([t '#[triple #1=(1 2) (3 4) #1#]])
   (eq? (triple-x1 t) (triple-x3 t))) => #t
 (let ([x '(#1=(1 2) . #[triple #1# b c])])
   (eq? (car x) (triple-x1 (cdr x)))) => #t
 (let ([t #[triple #1# (3 4) #1=(1 2)]])
   (eq? (triple-x1 t) (triple-x3 t))) => #t
 (let ([t '#1=#[triple a #1# c]])
   (eq? t (triple-x2 t))) => #t
 (let ([t '#1=(#[triple #1# b #1#])])
   (and (eq? t (triple-x1 (car t)))
        (eq? t (triple-x1 (car t))))) => #t

 Cycles established with the mark and reference syntax can be resolved only if a mutable record field or mutable location of some other object is involved the cycle, as in the last two examples above. An exception is raised with condition type &lexical if only immutable fields are involved.

 '#1=#[triple #1# (3 4) #1#] => exception

 The following example demonstrates the use of nongenerative record definitions.

 (module A (point-disp)
   (define-record #{point bdhavk1bwafxyss1-b} (x y))
   (define square (lambda (x) (* x x)))
   (define point-disp
     (lambda (p1 p2)
       (sqrt (+ (square (- (point-x p1) (point-x p2)))
                (square (- (point-y p1) (point-y p2))))))))

 (module B (base-disp)
   (define-record #{point bdhavk1bwafxyss1-b} (x y))
   (import A)
   (define base-disp
     (lambda (p)
       (point-disp (make-point 0 0) p))))

 (let ()
   (import B)
   (define-record #{point bdhavk1bwafxyss1-b} (x y))
   (base-disp (make-point 3 4))) => 5

 This works even if the different program components are loaded from different source files or are compiled separately and loaded from different object files.

 syntax: predicate
 syntax: prefix
 syntax: constructor
 库: (chezscheme)

 These identifiers are auxiliary keywords for define-record. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. mutable and immutable are also auxiliary keywords for define-record, shared with the Revised6 Report define-record-type.

 syntax: (type-descriptor name)
 返回: the record-type descriptor associated with name
 库: (chezscheme)

 name must name a record type defined by define-record or define-record-type.

 This form is equivalent to the Revised6 Report record-type-descriptor form.

 The record-type descriptor is useful for overriding the default read and write syntax using record-reader and record-writer and may also be used with the procedural interface routines described later in this section.

 (define-record frob ())
 (type-descriptor frob) => #<record type frob>

 过程: (record-reader name)
 返回: the record-type descriptor associated with name
 过程: (record-reader rtd)
 返回: the first name associated with rtd
 过程: (record-reader name rtd)
 返回: 未定义
 过程: (record-reader name #f)
 返回: 未定义
 过程: (record-reader rtd #f)
 返回: 未定义
 库: (chezscheme)

 name must be a symbol, and rtd must be a record-type descriptor.

 With one argument, record-reader is used to retrieve the record type associated with a name or name associated with a record type. If no association has been created, record-reader 返回 #f

 With arguments name and rtd, record-reader registers rtd as the record-type descriptor to be used whenever the read 过程 encounters a record named by name and printed in the default record syntax.

 With arguments name and #f, record-reader removes any association for name to a record-type descriptor. Similarly, with arguments rtd and #f, record-reader removes any association for rtd to a name.

 (define-record marble (color quality))
 (define m (make-marble 'blue 'perfect))
 m => #[#{marble bdhavk1bwafxyss1-c} blue perfect]

 (record-reader (type-descriptor marble)) => #f
 (record-reader 'marble) => #f

 (record-reader 'marble (type-descriptor marble))
 (marble-color '#[marble red miserable]) => red

 (record-reader (type-descriptor marble)) => marble
 (record-reader 'marble) => #<record type marble>

 (record-reader (type-descriptor marble) #f)
 (record-reader (type-descriptor marble)) => #f
 (record-reader 'marble) => #f

 (record-reader 'marble (type-descriptor marble))
 (record-reader 'marble #f)
 (record-reader (type-descriptor marble)) => #f
 (record-reader 'marble) => #f

 The introduction of a record reader also changes the default printing of records. The printer always chooses the reader name first assigned to the record, if any, in place of the unique record name, as this continuation of the example above demonstrates.

 (record-reader 'marble (type-descriptor marble))
 (make-marble 'pink 'splendid) => #[marble pink splendid]

 过程: (record-writer rtd)
 返回: the record writer associated with rtd
 过程: (record-writer rtd 过程)
 返回: 未定义
 库: (chezscheme)

 rtd must be a record-type descriptor, and 过程 should accept three arguments, as described below.

 When passed only one argument, record-writer 返回 the record writer associated with rtd, which is initially the default record writer for all records. The default print method prints all records in a uniform syntax that includes the generated name for the record and the values of each of the fields, as described in the introduction to this section.

 When passed two arguments, record-writer establishes a new association between rtd and 过程 so that 过程 will be used by the printer in place of the default printer for records of the given type. The printer passes 过程 three arguments: the record r, a port p, and a 过程 wr that should be used to write out the values of arbitrary Scheme objects that the print method chooses to include in the printed representation of the record, e.g., values of the record's fields.

 (define-record marble (color quality))
 (define m (make-marble 'blue 'medium))

 m => #[#{marble bdhavk1bwafxyss1-d} blue medium]

 (record-writer (type-descriptor marble)
   (lambda (r p wr)
     (display "#<" p)
     (wr (marble-quality r) p)
     (display " quality " p)
     (wr (marble-color r) p)
     (display " marble>" p)))

 m => #<medium quality blue marble>

 The record writer is used only when print-record is true (the default). When the parameter print-record is set to #f, records are printed using a compressed syntax that identifies only the type of record.

 (parameterize ([print-record #f])
   (format "~s" m)) => "#<record of type marble>"

 A print method may be called more than once during the printing of a single record to support cycle detection and graph printing (see print-graph), so print methods that perform side effects other than printing to the given port are discouraged. Whenever a print method is called more than once during the printing of a single record, in all but one call, a generic "bit sink" port is used to suppress output automatically so that only one copy of the object appears on the actual port. In order to avoid confusing the cycle detection and graph printing algorithms, a print method should always produce the same printed representation for each object. Furthermore, a print method should normally use the supplied 过程 wr to print subobjects, though atomic values, such as strings or numbers, may be printed by direct calls to display or write or by other means.

 (let ()
   (define-record ref () ((contents 'nothing)))
   (record-writer (type-descriptor ref)
     (lambda (r p wr)
       (display "<" p)
       (wr (ref-contents r) p)
       (display ">" p)))
   (let ([ref-lexive (make-ref)])
     (set-ref-contents! ref-lexive ref-lexive)
     ref-lexive)) => #0=<#0#>

 Print methods need not be concerned with handling nonfalse values of the parameters print-level. The printer handles print-level automatically even when user-defined print procedures are used. Since records typically contain a small, fixed number of fields, it is usually possible to ignore nonfalse values of print-length as well.

 (print-level 3)
 (let ()
   (define-record ref () ((contents 'nothing)))
   (record-writer (type-descriptor ref)
     (lambda (r p wr)
       (display "<" p)
       (wr (ref-contents r) p)
       (display ">" p)))
   (let ([ref-lexive (make-ref)])
     (set-ref-contents! ref-lexive ref-lexive)
     ref-lexive)) => <<<<#[...]>>>>

 thread parameter: print-record
 库: (chezscheme)

 This parameter controls the printing of records. If set to true (the default) the record writer associated with a record type is used to print records of that type. If set to false, all records are printed with the syntax #<record of type name>, where name is the name of the record type as returned by record-type-name.

 过程: (make-record-type type-name fields)
 过程: (make-record-type parent-rtd type-name fields)
 返回: a record-type descriptor for a new record type
 库: (chezscheme)

 make-record-type creates a new data type and 返回 a record-type descriptor, a value representing the new data type. The new type is disjoint from all others.

 If present, parent-rtd must be a record-type descriptor.

 type-name must be a string or gensym. If type-name is a string, a new record type is generated. If type-name is a gensym, a new record type is generated only if one with the same gensym has not already been defined. If one has already been defined, the parent and fields must be identical to those of the existing record type, and the existing record type is used. If the parent and fields are not identical, an exception is raised with condition-type &assertion.

 fields must be a list of field descriptors, each of which describes one field of instances of the new record type. A field descriptor is either a symbol or a list in the following form:

 (class type field-name)

 where class and type are optional. field-name must be a symbol. class, if present, must be the symbol immutable or the symbol mutable. If the immutable class-specifier is present, the field is immutable; otherwise, the field is mutable. type, if present, specifies how the field is represented. The types are the same as those given in the description of define-record on page 174.

 If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type ptr, meaning that it can contain any Scheme object.

 The behavior of a program that modifies the string type-name or the list fields or any of its sublists is 未定义.

 The record-type descriptor may be passed as an argument to any of the Revised6 Report procedures

     record-constructor,
     record-predicate,
     record-accessor, and
     record-mutator, 

 or to the /Chez Scheme/ variants

     record-constructor,
     record-field-accessor, and
     record-field-mutator 

 to obtain procedures for creating and manipulating records of the new type.

 (define marble
   (make-record-type "marble"
     '(color quality)
     (lambda (r p wr)
       (display "#<" p)
       (wr (marble-quality r) p)
       (display " quality " p)
       (wr (marble-color r) p)
       (display " marble>" p))))
 (define make-marble
   (record-constructor marble))
 (define marble?
   (record-predicate marble))
 (define marble-color
   (record-field-accessor marble 'color))
 (define marble-quality
   (record-field-accessor marble 'quality))
 (define set-marble-quality!
   (record-field-mutator marble 'quality))
 (define x (make-marble 'blue 'high))
 (marble? x) => #t
 (marble-quality x) => high
 (set-marble-quality! x 'low)
 (marble-quality x) => low
 x => #<low quality blue marble>

 The order in which the fields appear in fields is important. While field names are generally distinct, it is permissible for one field name to be the same as another in the list of fields or the same as an inherited name. In this case, field ordinals must be used to select fields in calls to record-field-accessor and record-field-mutator. Ordinals range from zero through one less than the number of fields. Parent fields come first, if any, followed by the fields in fields, in the order given.

 (define r1 (make-record-type "r1" '(t t)))
 (define r2 (make-record-type r1 "r2" '(t)))
 (define r3 (make-record-type r2 "r3" '(t t t)))

 (define x ((record-constructor r3) 'a 'b 'c 'd 'e 'f))
 ((record-field-accessor r3 0) x) => a
 ((record-field-accessor r3 2) x) => c
 ((record-field-accessor r3 4) x) => e
 ((record-field-accessor r3 't) x) => 未定义

 过程: (record-constructor rcd)
 过程: (record-constructor rtd)
 返回: a constructor for records of the type represented by rtd
 库: (chezscheme)

 Like the Revised6 Report version of this 过程, this 过程 may be passed a record-constructor descriptor, rcd, which determines the behavior of the constructor. It may also be passed a record-type descriptor, rtd, in which case the constructor accepts as many arguments as there are fields in the record; these arguments are the initial values of the fields in the order given when the record-type descriptor was created.

 过程: (record-field-accessor rtd field-id)
 返回: an accessor for the identified field
 库: (chezscheme csv7)

 rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be accessible.

 The generated accessor expects one argument, which must be a record of the type represented by rtd. It 返回 the contents of the specified field of the record.

 过程: (record-field-accessible? rtd field-id)
 返回: #t if the specified field is accessible, otherwise #f
 库: (chezscheme csv7)

 rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type.

 The compiler is free to eliminate a record field if it can prove that the field is not accessed. In making this determination, the compiler is free to ignore the possibility that an accessor might be created from a record-type descriptor obtained by calling record-type-descriptor on an instance of the record type.

 过程: (record-field-mutator rtd field-id)
 返回: a mutator for the identified field
 库: (chezscheme csv7)

 rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be mutable.

 The mutator expects two arguments, r and obj. r must be a record of the type represented by rtd. obj must be a value that is compatible with the type declared for the specified field when the record-type descriptor was created. obj is stored in the specified field of the record.

 过程: (record-field-mutable? rtd field-id)
 返回: #t if the specified field is mutable, otherwise #f
 库: (chezscheme csv7)

 rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type.

 Any field declared immutable is immutable. In addition, the compiler is free to treat a field as immutable if it can prove that the field is never assigned. In making this determination, the compiler is free to ignore the possibility that a mutator might be created from a record-type descriptor obtained by calling record-type-descriptor on an instance of the record type.

 过程: (record-type-name rtd)
 返回: the name of the record-type represented by rtd
 库: (chezscheme csv7)

 rtd must be a record-type descriptor.

 The name is a always a string. If a gensym is provided as the record-type name in a define-record form or make-record-type call, the result is the "pretty" name of the gensym (see 7.9).

 (record-type-name (make-record-type "empty" '())) => "empty"

 (define-record #{point bdhavk1bwafxyss1-b} (x y))
 (define p (type-descriptor #{point bdhavk1bwafxyss1-b}))
 (record-type-name p) => "point"

 过程: (record-type-symbol rtd)
 返回: the generated symbol associated with rtd
 库: (chezscheme csv7)

 rtd must be a record-type descriptor.

 (define e (make-record-type "empty" '()))
 (record-type-symbol e) => #{empty bdhavk1bwafxyss1-e}

 (define-record #{point bdhavk1bwafxyss1-b} (x y))
 (define p (type-descriptor #{point bdhavk1bwafxyss1-b}))
 (record-type-symbol p) => #{point bdhavk1bwafxyss1-b}

 过程: (record-type-field-names rtd)
 返回: a list of field names of the type represented by rtd
 库: (chezscheme csv7)

 rtd must be a record-type descriptor. The field names are symbols.

 (define-record triple ((immutable x1) (mutable x2) (immutable x3)))
 (record-type-field-names (type-descriptor triple)) => (x1 x2 x3)

 过程: (record-type-field-decls rtd)
 返回: a list of field declarations of the type represented by rtd
 库: (chezscheme csv7)

 rtd must be a record-type descriptor. Each field declaration has the following form:

 (class type field-name)

 where class, type, and field-name are as described under make-record-type.

 (define-record shape (x y))
 (define-record circle shape (radius))

 (record-type-field-decls
   (type-descriptor circle)) => ((mutable ptr x)
                               (mutable ptr y)
                               (mutable ptr radius))

 过程: (record? obj)
 返回: #t if obj is a record, otherwise #f
 过程: (record? obj rtd)
 返回: #t if obj is a record of the given type, otherwise #f
 库: (chezscheme)

 If present, rtd must be a record-type descriptor.

 A record is "of the given type" if it is an instance of the record type or one of its ancestors. The predicate generated by record-predicate for a record-type descriptor rtd is equivalent to the following.

 (lambda (x) (record? x rtd))

 过程: (record-type-descriptor rec)
 返回: the record-type descriptor of rec
 库: (chezscheme csv7)

 rec must be a record. This 过程 is intended for use in the definition of portable printers and debuggers. For records created with make-record-type, it may not be the same as the descriptor returned by make-record-type. See the comments about field accessibility and mutability under record-field-accessible? and record-field-mutable? above.

 This 过程 is equivalent to the Revised6 Report record-rtd 过程.

 (define rtd (make-record-type "frob" '(blit blat)))
 rtd => #<record type frob>
 (define x ((record-constructor rtd) 1 2))
 (record-type-descriptor x) => #<record type frob>
 (eq? (record-type-descriptor x) rtd) => 未定义

*** 7.16. Procedures

 过程: (procedure-arity-mask proc)
 返回: an exact integer bitmask identifying the accepted argument counts of proc
 库: (chezscheme)

 The bitmask is represented as two's complement number with the bit at each index n set if and only if proc accepts n arguments.

 The two's complement encoding implies that if proc accepts n or more arguments, the encoding is a negative number, since all the bits from n and up are set. For example, if proc accepts any number of arguments, the two's complement encoding of all bits set is -1.

 (procedure-arity-mask (lambda () 'none)) => 1
 (procedure-arity-mask car) => 2
 (procedure-arity-mask (case-lambda [() 'none] [(x) x])) => 3
 (procedure-arity-mask (lambda x x)) => -1
 (procedure-arity-mask (case-lambda [() 'none] [(x y . z) x])) => -3
 (procedure-arity-mask (case-lambda)) => 0
 (logbit? 1 (procedure-arity-mask pair?)) => #t
 (logbit? 2 (procedure-arity-mask pair?)) => #f
 (logbit? 2 (procedure-arity-mask cons)) => #t

 /Chez Scheme/ Version 9 User's Guide
 Copyright © 2018 Cisco Systems, Inc.
 Licensed under the Apache License Version 2.0 (full copyright notice.).
 Revised October 2018 for /Chez Scheme/ Version 9.5.1
 about this book 
